{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-02-27T01:51:34.190399+00:00",
  "repo": "tlswg/tls-trust-anchor-ids",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "trust-expressions",
      "description": "",
      "color": "bfdadc"
    },
    {
      "name": "trust-anchor-ids",
      "description": "",
      "color": "A03D7B"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOKigz-s50ZUKW",
      "title": "Allow pruning deactivated trust anchors?",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/issues/1",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "trust-expressions"
      ],
      "body": "The document is currently written to be append-only, which is correct for X.509 and also shouldn't grow significantly. @bwesterb points out Merkle tree certs have different properties:\r\n\r\n1. MTC trust anchors are minted every hour\r\n2. MTC trust anchors naturally deactivate themselves\r\n\r\nProperty 1 means the manifest will grow over time and potentially get unwieldy. But property 2 implies an easy fix. Once an MTC trust anchor expires, there is no benefit to listing it in the manifest beyond historical interest. So we could potentially allow those to get trimmed. That will, in turn, allow trimming the old versions since they become empty. We have no way to express either of these, so we may want to add some allowance for this in the format.\r\n\r\nWe also don't necessarily need to do this here. Since the manifest document is consumed by just the root programs and CAs, who know what type of CA they are, we can always put this extra allowance in the MTC document. But it would be convenient if the changes slot nicely into the existing format, so we may want to look at this a bit.",
      "createdAt": "2023-10-19T18:00:38Z",
      "updatedAt": "2025-02-22T00:46:57Z",
      "closedAt": "2025-02-22T00:46:57Z",
      "comments": [
        {
          "author": "aarongable",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This was my first thought when I read the draft -- unlimited growth with no way to prune old versions which contain only expired anchors will be a footgun, whether it's for reasons we can forsee right now or not. I'm strongly in favor of allowing pruning.",
          "createdAt": "2023-11-20T20:51:01Z",
          "updatedAt": "2023-11-20T20:51:01Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Other than syntactic concerns (we'd need to start the counter later in the JSON document, or add a `version` key), I think the main consideration with pruning them is what happens to older RPs:\r\n\r\nA root program might stop really paying attention to old relying parties after, let's say, 1 year. (I'm making this number up.) E.g. If some Chrome hasn't taken software or component updates for so long, it's probably going to stay that way. Even if the private key of one of its CAs leaked online, if we cannot push code or config to those clients, we can't help them anyway.\r\n\r\nBut that says nothing about whether web servers care about serving those Chromes (and anyone else using the trust store version). That may happen for longer. Examples:\r\n\r\n* Maybe some old version of Chromium ended up in an old Electron that some popular apps are still using\r\n* Maybe this is on unupdated copy of WebView\r\n* Maybe this server is part of some enterprise deployment that has intentionally stayed on a very old Chrome\r\n* Maybe this server is just very popular and very risk-averse and doesn't want to stop serving those clients\r\n* Maybe this isn't Chromium at all, but and some other root program spun off, forked off of the Chrome list initially, and is still sending an old Chrome trust store name for compatibility while certs update their metadata.\r\n* Maybe this is some random IoT device that copied the root store as of some year and never updated it ever again\r\n\r\nCAs will need metadata about those old trust store versions for as long as they wish to serve subscribers that, in turn, which to serve these relying parties. In most of these cases, that schedule is completely detached from the root program that maintains the manifest.\r\n\r\nThis doesn't _really_ matter because the old versions are frozen and the CA can always just hold on to the old file before the root program stops trying to serve it. But I'm sure folks will mess this up, and it seems easier to not tempt fate if the growth isn't actually a problem. (Of course, if it is a problem, that's a whole different matter. I also wouldn't want to tempt fate if we think growth is fine and it turns out to be bad...)\r\n\r\nAside: There is arguably _a_ way to prune it as-is. It's just gross and terrible. :-) Just make a new trust store name. But this causes a minor bit of disruption at the transition point. (I think RPs would need to send trust expressions for both names for a spell.) Depending on how unforeseeable this unforeseen thing is, that can always been an option in a pinch. ",
          "createdAt": "2023-11-20T23:04:49Z",
          "updatedAt": "2023-11-20T23:07:06Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDOKigz-s501GPP",
      "title": "Tidy up who prepares trust expressions",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/issues/3",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "trust-expressions"
      ],
      "body": "We mostly want it to be the root program, but relying parties might end up tweaking things if, say, something is conditioned on software version. I was envisioning the root program sends down some private structure like \"also include these exclusions under these conditions\", etc., but that's very hard to describe.\r\n\r\nPerhaps a better separation is to say:\r\n* Root programs compute the compatibility exclusions\r\n* Better yet, stick them in the manifest so people can easily use them; root programs periodically recompute them to trim away stuff they don't need anymore\r\n* Relying parties take the mandatory ones from the manifest and then add in their own as needed. If that task is half done by the software vendor and half done on the client device, that's the application's business, but we describe it as the relying party doing it.\r\n\r\nThe problem is that computing exclusions is a little tricky. Maybe we need to mark which label is the singleton one, so that computing the label set is always possible? This does add quite a lot more moving parts though.",
      "createdAt": "2023-10-24T21:07:21Z",
      "updatedAt": "2025-02-25T19:03:26Z",
      "closedAt": "2025-02-25T19:03:24Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Missed this one. Meant to close it with the others.",
          "createdAt": "2025-02-25T19:03:24Z",
          "updatedAt": "2025-02-25T19:03:24Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDOKigz-s52V37W",
      "title": "Limit to TLS 1.3 and up",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/issues/4",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The certificate message extension doesn't work otherwise. Just add a sentence somewhere.",
      "createdAt": "2023-11-09T11:42:20Z",
      "updatedAt": "2024-05-29T16:04:02Z",
      "closedAt": "2024-05-29T16:04:02Z",
      "comments": []
    },
    {
      "number": 6,
      "id": "I_kwDOKigz-s5_Y37F",
      "title": "Does CertificatePropertyList confer any semantics on its own?",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/issues/6",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In prototyping some subscriber support, one thing came up: trust-expression-enabled credentials are different from normal credentials:\r\n\r\n* The credentials are expected to be gated on trust expressions, or some other kind of issuer negotiation. (You could imagine also checking the `certificate_authorities` extension, or other mechanisms.)\r\n* Due to this negotiation, the credentials are expected be exact certificate paths, with nothing extra or missing. In particular, this means it should be safe for the subscriber to check against the `signature_algorithms` and `signature_algorithms_cert` without worrying about stray MD2 self-signed roots.\r\n\r\nHowever, CertificatePropertyList is extensible, which is nice because it allows us to introduce other kinds of properties without changing the CA -> server software -> TLS library flow. It's basically a grab-bag of any kind of CA -> server software communication.\r\n\r\nBut this, combined with wanting to minimize how much layers in between need to inspect CertificatePropertyList puts us in a pickle: what does it mean if you get a CertificatePropertyList without any trust expression property? Maybe it's got some other property you don't understand. Does it still imply that it's still issuer-gated and a whole path?\r\n\r\nIf yes, the extensibility is less useful. There may well be use cases that don't want to be issuer-gated.\r\nIf no, we don't want the certificate to accidentally get interpreted as non-issuer-gated when it actually was issuer-gated by some other mechanism.\r\n\r\nIn writing this, I think I'm coming around to \"no\" being the right answer, but then...\r\n* Should the caller be required to call some \"this is an issuer-gated credential\" API? I.e. we use an out-of-band signal rather than relying on in-band signals that might disappear.\r\n* Do we have a general \"this is issuer-gated\" property and say everyone must understand this? That seems a bit weird.\r\n* Do we need to invent critical properties??? \ud83d\ude2d ",
      "createdAt": "2024-02-15T19:01:39Z",
      "updatedAt": "2024-12-06T17:25:54Z",
      "closedAt": "2024-12-06T17:25:54Z",
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "NONE",
          "body": "What about:\r\n\r\n1. If there is a trust expression property, ignore other properties you don't understand.\r\n2. If there are no properties you understand, ignore the credential.\r\n\r\nNew properties can define different semantics as desired.",
          "createdAt": "2024-02-16T18:12:13Z",
          "updatedAt": "2024-02-16T18:12:13Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "What if, say, we moved SCT lists to a certificate property (could be a convenient way for the CA to deliver them and allow the server to negotiate which to send)? If you see only that property, do you ignore the credential?\r\n\r\nBob, Devon, and I talked a bit about this earlier and are currently leaning towards the first of the three options: CPLs are just a bag of data, and it's on the TLS library user to say \"this credential needs to match the issuer\" and \"I believe this credential is ubiquitous and a viable candidate for the default\".\r\n\r\nIt does make the API a bit more annoying, but that does ultimately translate to what probably the application's config file will be: a new directive for \"here are my negotiated certs\". (Or \"here are some ACME URLs to get negotiated certs\".) You need a new one mostly because the existing one has an implicit \"this is ubiquitous\" semantic.",
          "createdAt": "2024-02-17T14:11:55Z",
          "updatedAt": "2024-02-17T14:11:55Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Forgot this was open, but I think we've mostly settled on the interpretation above. https://github.com/davidben/tls-trust-expressions/pull/21 makes this a bit more explicit too in its example. Leaving this open just because we probably do need some text on the implications for the ACME bits.",
          "createdAt": "2024-05-29T12:44:49Z",
          "updatedAt": "2024-05-29T12:44:49Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Think I'll just close this. Not sure what ACME text I was thinking and probably wouldn't belong in this doc anyway.",
          "createdAt": "2024-12-06T17:25:54Z",
          "updatedAt": "2024-12-06T17:25:54Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOKigz-s6A4l7W",
      "title": "Rework introduction after explainer",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/issues/8",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I wrote the explainer document in part by taking the introduction text and wordsmithing it a bit. I think the version in the explainer is a bit clearer. Let's backport some of those clarity improvements into the draft itself.",
      "createdAt": "2024-03-01T00:26:54Z",
      "updatedAt": "2024-03-04T23:17:39Z",
      "closedAt": "2024-03-04T23:17:38Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "This is done.",
          "createdAt": "2024-03-04T23:17:38Z",
          "updatedAt": "2024-03-04T23:17:38Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "I_kwDOKigz-s6BM3vN",
      "title": "Allow CA signatures to be opaque to the subscriber",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/issues/9",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Imagine we have a PKI and would like to transition the roots from one algorithm to another. This could be classical to post-quantum, or perhaps the current round of post-quantum algorithms to a future, more size-efficient one.\r\n\r\nThe subscribers keys will unavoidably require manual work by the subscriber. But everything beyond the subscriber key (what Merkle Tree Certificate's [BikeshedCertificate](https://davidben.github.io/merkle-tree-certs/draft-davidben-tls-merkle-tree-certs.html#name-certificate-format) calls the \"proof\") is purely a matter between the CA and relying party. The subscriber *does not need to process them*. It would be nice if CAs could transparently start issuing you a classical-rooted certificate and a PQ-rooted certificate, and then certificate negotiation automatically takes care of it.\r\n\r\nIn particular, though this doesn't get the EE keys, a world with PQ roots and mixed PQ and classical EE keys is actually still coherent because we have a PQ-secure signal[*] that the site is not yet ready to be PQ-secure. Separating the transitions will be useful. And, of course, when transitioning between PQ-old-and-big vs PQ-new-and-small, the mix is straightforwardly coherent.\r\n\r\nWe *almost* have the pieces of this, except for one problem: X.509 is a bad fit for TLS. TLS uses code points, while X.509 negotiations with (sometimes [comically unusable](https://www.rfc-editor.org/rfc/rfc4055.html)) AlgorithmIdentifiers. A TLS stack cannot map between them without recognizing the signature algorithm. This means CA signatures in X.509, unlike BikeshedCertificate, are *not* opaque to the subscriber. In particular, although very few folks implement it (without trust expressions, there are path-building problems), RFC 8446 technically [requires](https://www.rfc-editor.org/rfc/rfc8446#section-4.4.2.2) the subscriber check this before presenting a certificate.\r\n\r\nWe can fix this by adding a `signature_algorithms` certificate property, that contains the CA-extracted codepoints in TLS syntax. If the property is present, the subscriber's TLS software should check those against the ClientHello in lieu of trying to parse this messy data out of the certificate.\r\n\r\n[*] Well, sort of. The existence of a P-256 certificate does not imply the non-existence of an ML-DSA certificate. We may need a bit more pieces to make that transition state viable.",
      "createdAt": "2024-03-04T19:56:37Z",
      "updatedAt": "2024-12-06T18:57:33Z",
      "closedAt": "2024-12-06T18:57:33Z",
      "comments": []
    },
    {
      "number": 10,
      "id": "I_kwDOKigz-s6DFL9f",
      "title": "Remove trustExpressions request boolean",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/issues/10",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bob-beck"
      ],
      "labels": [],
      "body": "Per feedback from @aarongable, it's probably better to omit the the trustExpressions boolean for now. It was intended to accommodate some more complex issuance cases, but it's probably better to resolve that in a separate document, since general multiple issuance may require much more complicated ACME bits anyway. Let's start with just the Accept HTTP request header and the MIME type and we can add more extensions later.",
      "createdAt": "2024-03-21T05:46:14Z",
      "updatedAt": "2024-03-22T21:50:57Z",
      "closedAt": "2024-03-22T21:50:57Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "This is now done.",
          "createdAt": "2024-03-22T21:50:57Z",
          "updatedAt": "2024-03-22T21:50:57Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "I_kwDOKigz-s6EuBAN",
      "title": "Decide how to allocate trust store names",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/issues/12",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Merkle Tree certificates will have a similar problem in naming CAs. And honestly even for X.509 certificates, a shorter name would be valuable.\r\n\r\nGoofy as ASN.1 is, we're actually thinking OIDs right now. Specifically OIDs under the [Private Enterprise Number (PEN) arc](https://www.rfc-editor.org/rfc/rfc9371.html), probably represented as a DER-encoded `RELATIVE-OID` contents, excluding the tag and length, relative to the `1.3.6.1.4.1` prefix, avoid an unnecessary 5 bytes.\r\n\r\nThis is nice because:\r\n* Anyone can register them, so there's an easy answer for private PKIs\r\n* They're pretty compact; the largest PEN so far fits in 3 bytes, and then an organization should only need a couple more bytes past that, even if they've already been using their namespace. We're unlikely to ever allocate a 4-byte PEN.\r\n* While not directly useful for this draft, the hierarchical nature might be handy for MTCs, which have a two-layer thing going on\r\n* It seems perhaps handy for MTC CA names and trust stores to not collide. You could potentially use an MTC CA name as an implicit trust store. (Not yet thought through.)",
      "createdAt": "2024-04-04T22:55:37Z",
      "updatedAt": "2024-07-10T16:04:56Z",
      "closedAt": "2024-07-10T16:04:56Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "This is now done.",
          "createdAt": "2024-07-10T16:04:56Z",
          "updatedAt": "2024-07-10T16:04:56Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "I_kwDOKigz-s6HzX5p",
      "title": "How do trust expressions and sctNotAfter removals work?",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/issues/13",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "trust-expressions"
      ],
      "body": "I suspect there is a way to express this with the draft as-is, since you just need newly-issued certificates to stop being associated with newer versions of the trust store, but filing this so we remember to think about this.",
      "createdAt": "2024-05-03T20:38:17Z",
      "updatedAt": "2025-02-22T00:46:56Z",
      "closedAt": "2025-02-22T00:46:56Z",
      "comments": []
    },
    {
      "number": 17,
      "id": "I_kwDOKigz-s6KDjrS",
      "title": "Write up design considerations section",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/issues/17",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "devonobrien"
      ],
      "labels": [
        "trust-expressions"
      ],
      "body": "We ought to document the design rationale somewhere. Some things we could discuss:\r\n\r\n* All the complications around how we need to handle version skew\r\n* Growth of manifest list over time \r\n* Growth of TrustStoreInclusion metadata overtime",
      "createdAt": "2024-05-24T20:13:56Z",
      "updatedAt": "2025-02-22T00:46:56Z",
      "closedAt": "2025-02-22T00:46:56Z",
      "comments": []
    },
    {
      "number": 18,
      "id": "I_kwDOKigz-s6KDt-7",
      "title": "\"SHOULD NOT use path building\" is a bit strong",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/issues/18",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Let's downgrade to MAY and then explain why you might want to. Namely:\r\n* More predictable behavior\r\n* Encourage servers to behave correctly",
      "createdAt": "2024-05-24T20:46:18Z",
      "updatedAt": "2024-05-29T16:03:34Z",
      "closedAt": "2024-05-29T16:03:34Z",
      "comments": []
    },
    {
      "number": 19,
      "id": "I_kwDOKigz-s6KD0kl",
      "title": "Tidy up subscriber selection algorithm",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/issues/19",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I think we're a bit too prescriptive in the subscriber behavior section:\r\nhttps://davidben.github.io/tls-trust-expressions/draft-davidben-tls-trust-expr.html#name-subscriber-behavior\r\n\r\nSpecifically, it's written as if you first look for a TE-based match, then you consider other stuff like CA. Instead, I think the right model is:\r\n\r\n* Here is how you use TE to get a positive signal of trust anchor match. TE might tell you \"yes, it matches\" or \"unknown\"\r\n* The `certificate_authorities` extension can also give you a similar signal.\r\n* Other extensions might be defined later to similarly handle trust negotiation\r\n* If any such extension says \"yes, it matches\", you have a trust anchor match. Otherwise it's unknown whether the server trusts the path.\r\n\r\nFrom there, the subscriber has free reign to decide how it selects a credential based on this \"trust anchor match\" signal. One possible scheme (but not the only one) is:\r\n\r\n* Subscriber maintains a list of credentials, in preference order, e.g. sorted by size or speed of signing key\r\n* Some credentials require a trust anchor match, presumably the ones at the front of the queue\r\n* Other credentials skip this check because they're fallback credentials, presumably the ones at the end of the queue\r\n* Pick the first credential that matches",
      "createdAt": "2024-05-24T21:05:20Z",
      "updatedAt": "2024-05-30T17:29:18Z",
      "closedAt": "2024-05-30T17:29:18Z",
      "comments": [
        {
          "author": "martinschmatz",
          "authorAssociation": "NONE",
          "body": "Just FYI: I was playing around with the idea to pack the information intended to be transported in the proposed new `trust_expressions` extension in \"fake\" root certs which can be sent to the subscriber using the _existing_ `certificate_authorities` extension \"which SHOULD be used by the receiving endpoint to guide certificate selection\" as per [RFC](https://datatracker.ietf.org/doc/html/rfc8446#section-4.2.4) (read: The server is free how to use the information). \r\n\r\nIt is easy to create a self signed \"root cert\" with some base64 encoded information in CN etc fields to help the subscriber in the selection of the certificate chain to use for authentication. ",
          "createdAt": "2024-05-29T12:23:18Z",
          "updatedAt": "2024-05-29T12:23:18Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi @martinschmatz, thanks for the comment. As this has nothing to do with this issue, I've filed https://github.com/davidben/tls-trust-expressions/issues/23 so we can move the discussion there.",
          "createdAt": "2024-05-29T12:39:45Z",
          "updatedAt": "2024-05-29T12:39:45Z"
        },
        {
          "author": "martinschmatz",
          "authorAssociation": "NONE",
          "body": "Sure @davidben - I added it here because it might be that the first two bullets above could merge, thereby avoiding the hassle to convince people to change the TLSv1.3 RFC. \r\n\r\nJoining #23 ",
          "createdAt": "2024-05-29T13:02:41Z",
          "updatedAt": "2024-05-29T13:02:41Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "I_kwDOKigz-s6KeZWJ",
      "title": "Packing trust_expressions into certificate_authorities",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/issues/23",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "trust-expressions"
      ],
      "body": "@martinschmatz wrote the following on https://github.com/davidben/tls-trust-expressions/issues/19#issuecomment-2137282741\r\n\r\n> Just FYI: I was playing around with the idea to pack the information intended to be transported in the proposed new `trust_expressions` extension in \"fake\" root certs which can be sent to the subscriber using the _existing_ `certificate_authorities` extension \"which SHOULD be used by the receiving endpoint to guide certificate selection\" as per [RFC](https://datatracker.ietf.org/doc/html/rfc8446#section-4.2.4) (read: The server is free how to use the information). \r\n>\r\n> It is easy to create a self signed \"root cert\" with some base64 encoded information in CN etc fields to help the subscriber in the selection of the certificate chain to use for authentication. \r\n\r\nMoving this to a separate issue as issue #19 is about something completely unrelated.\r\n\r\n@martinschmatz, could you perhaps expand on this? I don't see what benefit it would have, but some of the details don't make sense to me, so perhaps I am misunderstanding.\r\n\r\nFirst, the `certificate_authorities` extension doesn't carry certificates but names. So there wouldn't be a root certificate in the first place. Base64 encoding also sounds like unnecessarily wasteful (keep in mind we want a compact scheme), though one could use a new OCTET-STRING-carrying attribute. That would still be wasteful with the rest of the ASN.1 structure, but much less so.\r\n\r\nSecond, even though RFC 8446 does not prescribe a precise way to use the information, no one implements a trust expressions matching algorithm with it today. They'll all do some variation of checking for a matching issuer among the relying party's list, because those are the semantics of the field. The allowance is because there are lots of ways to do that and integrate it with other processes.\r\n\r\nIf we were to imbue an existing field with new semantics, we're going to need a code change in the TLS stack anyway. (And, to reduce server operator burden, I think it's important that the matching algorithm be in the TLS stack, at least long-term.) At that point, there is no cost to using a new extension, so we may as well define an extension with the right semantics.\r\n\r\nFinally, there is a real cost to jamming new semantics into existing fields. In addition to the wasteful encoding, this risks weird behaviors when existing software interprets the field according to its existing semantics.",
      "createdAt": "2024-05-29T12:39:09Z",
      "updatedAt": "2024-07-25T20:42:27Z",
      "closedAt": "2024-07-25T20:42:27Z",
      "comments": [
        {
          "author": "martinschmatz",
          "authorAssociation": "NONE",
          "body": "While I value your effort towards better [crypto-]agility, I'm concerned that it'll take many years for those features to reach OS dist packages. I most certainly support your view that a server should have several cert chains available and adaptively select one pending information received by the client during TLS handshake. \r\n\r\nI therefore played around with a [much] simpler approach by sneaking information into the `certificate_authorities` extension. This explicitly not with the desire to increase agility, but to nevertheless help in the selection of the several available cert chains.\r\n\r\nAs a super simplified example, let's assume a \"fake\" root cert is built like this: \r\n```\r\nSIGALG_default=prime256v1\r\nopenssl ecparam -genkey \\\r\n                -name $SIGALG_default \\\r\n                -noout \\\r\n                -out CA_default.key \\\r\n&& \\\r\nopenssl req \\\r\n                -config /etc/pki/tls/openssl.cnf \\\r\n                -key CA_default.key \\\r\n                -subj '/ST=I want purely QSC cert chain/L=Please use Germany as geo/CN=I want sec level 5' \\\r\n                -new \\\r\n                -x509 \\\r\n                -days 7300 \\\r\n                -extensions v3_ca \\\r\n                -out CA_default.crt\r\n```\r\n\r\nThe `-subj` line is the place where cert-chain-selection-hints are added. As you can see, I expect a reasonably small, highly pragmatic set of selection parameters\r\n- Legacy, QSC, Hybrid sigalgs\r\n- The geo will give a good hint about mandated algs \r\n- The security level is key for interactions with gov\r\n- Potentially some very few more \r\n\r\nFew comments to the above: \r\n- 'cost' is small: The above adds 110 Bytes to a `ClientHello` in the `certificate_authorities` extension and can be further reduced quite a bit by anyway preferred \"code points\" (`-subj '/ST=0x2345/L=Ox4444/CN=0x0005'` adds 57 bytes only) \r\n- Per request specification of `signature_algorithms` extension can not be expected to be easily supported by the gazillion of client apps, while a general description of what the client expects will not necessarily change between requests.\r\n- Implicitly, I'm expecting a gradual, but at least initially slow growth of CAs to support Q-safe root certs. Clients will then have two cert bundles, one legacy and one Q-safe. And it'll be the clients responsibility to have the 'usual suspects' CA for the features the client is asking in its cert bundle.\r\n- Yes, servers must implement code changes, but the clients not. \r\n\r\nAs for the specific use of \"fake root certs\" for the `certificate_authorities` extension in the TE context: In the mean time, I have the suspicion that the entries in your `trust_expressions` extensions might quite likely exceed (?) the max number of characters for the x509 fields transported via `certificate_authorities` extension. It would therefore not be a valid option for TE. \r\n",
          "createdAt": "2024-05-29T16:31:37Z",
          "updatedAt": "2024-05-29T16:32:36Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this as I don't think we want to overload the existing `certificate_authorities` extension with completely different semantics.",
          "createdAt": "2024-07-25T20:42:27Z",
          "updatedAt": "2024-07-25T20:42:27Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "I_kwDOKigz-s6Kp5ZT",
      "title": "A server supporting trust expressions needs to have accurate time. ",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/issues/25",
      "state": "CLOSED",
      "author": "bob-beck",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "trust-expressions"
      ],
      "body": "While possibly not an unusual requirement in 2024, Today, a server serving a certificate does not need to know the time, the only time that matters is the client's notion of time to evaluate the validity of the certificate. \r\n\r\nWe need to call out that (in absence of other things) the server's time causing trust expresions to not choose a certificate it believes is expired could result in the default certificate being sent to a client that would otherwise have been presented with an expired certificate, and be allowed to possibly decide based on it's own notion of time that it was fine, (or that it did not care)\r\n\r\nI *think* this change is kind of \"ok\" but it is certainly a change compared to today. \r\n\r\n",
      "createdAt": "2024-05-30T17:48:50Z",
      "updatedAt": "2025-02-22T00:46:56Z",
      "closedAt": "2025-02-22T00:46:56Z",
      "comments": []
    },
    {
      "number": 26,
      "id": "I_kwDOKigz-s6Kp9m5",
      "title": "A client does not get a chance to evaluate a non-matching certificate of a trust expression. ",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/issues/26",
      "state": "CLOSED",
      "author": "bob-beck",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "trust-expressions"
      ],
      "body": "\r\nHow important this is we are unsure, but if a client sending a trust expression sends a non matching trust expression that\r\nthe server does not choose (because for example, the server has a distrusted root, time, etc) The client does not then get\r\nto look at what the server would have sent, but instead sees the (possibly very legacy) fallback certificate. \r\n\r\nAs an example, we could have a client that trusts entirely a new set of roots (PQ?) and then instead of being offered a choice\r\nof an \"older less trusted or expired\" PQ cert that it might choose to work with, It instead gets a fallback certifiate with classical algorithms it does not even support. \r\n\r\n",
      "createdAt": "2024-05-30T18:00:37Z",
      "updatedAt": "2025-02-22T00:46:55Z",
      "closedAt": "2025-02-22T00:46:55Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Not going to bulk-close the TE bugs yet, but just for posterity: the TAI design solves this problem with the retry mechanism.",
          "createdAt": "2024-12-14T19:22:26Z",
          "updatedAt": "2024-12-14T19:22:26Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "I_kwDOKigz-s6L4uGB",
      "title": "Single-certificate and multi-certificate terms are a bit confusing",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/issues/28",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Without trust anchor negotiation, people sometimes do deploy multiple certificates today. It's not enough to avoid preventing PKI evolution, but it means the terminology is a little bit confusing.",
      "createdAt": "2024-06-11T17:06:14Z",
      "updatedAt": "2024-12-14T19:20:15Z",
      "closedAt": "2024-12-14T19:20:15Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Think we can call this done. The explainer still uses these terms, but meh.",
          "createdAt": "2024-12-14T19:20:15Z",
          "updatedAt": "2024-12-14T19:20:15Z"
        }
      ]
    },
    {
      "number": 41,
      "id": "I_kwDOKigz-s6PHsH9",
      "title": "Add a copy of the ASN.1 module to an appendix",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/issues/41",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "trust-anchor-ids"
      ],
      "body": "Requested by Russ Housley. There's not much ASN.1 here, but we do have an X.509 extension.",
      "createdAt": "2024-07-10T16:05:54Z",
      "updatedAt": "2024-12-16T22:03:02Z",
      "closedAt": "2024-12-16T22:03:02Z",
      "comments": []
    },
    {
      "number": 51,
      "id": "I_kwDOKigz-s6QwuPD",
      "title": "Make trust anchor IDs document standalone ",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/issues/51",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "trust-anchor-ids"
      ],
      "body": "The parts that were incorporated by reference from TE should be moved in as the canonical versions.",
      "createdAt": "2024-07-25T00:20:18Z",
      "updatedAt": "2024-09-06T13:52:49Z",
      "closedAt": "2024-09-06T13:52:49Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "This is done now. Only reference now is the appendix.",
          "createdAt": "2024-09-06T13:52:49Z",
          "updatedAt": "2024-09-06T13:52:49Z"
        }
      ]
    },
    {
      "number": 53,
      "id": "I_kwDOKigz-s6Q5KMx",
      "title": "Design an in-handshake retry for trust anchor IDs",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/issues/53",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "trust-anchor-ids"
      ],
      "body": "This is better figured out post-adoption, but if we could do the retry in-handshake, rather than on a new connection, it would be easier for clients to deploy because the retry could be done inside the TLS stack.\r\n\r\nPossible directions:\r\n\r\n1. Add a new message, somewhere after the ServerHello, to trigger an extra roundtrip under handshake encryption.\r\n2. Use HelloRetryRequest. The challenge is that ECH did not opt to encrypt HelloRetryRequest, so that might leak information about the target service. We could potentially define some way to start encrypting that.",
      "createdAt": "2024-07-25T20:10:58Z",
      "updatedAt": "2024-07-25T23:07:45Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 54,
      "id": "I_kwDOKigz-s6Q5Pny",
      "title": "Negotiate SCTs alongside roots, etc.",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/issues/54",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "trust-anchor-ids"
      ],
      "body": "Sometimes X.509 credentials are accompanied with SCTs in the `signed_certificate_timestamp` extension. This isn't widely deployed, but being able to negotiate SCTs would be valuable for much the same reasons. Future credential types may also have a need for separately negotiable sub-parts.\r\n\r\nA brief sketch:\r\n\r\nFirst, allocate a trust anchor ID for each CT log.\r\n\r\nNext, define a `signed_certificate_timestamp` certificate property. It contains something like this. (Replace structure names with something more sensible.)\r\n\r\n```\r\nenum {\r\n    signed_certificate_timestamps(TBD), (2^16-1)\r\n} CertificatePropertyType;\r\n\r\nopaque SerializedSCT<1..2^16-1>;  // From RFC 6962\r\n\r\nstruct {\r\n    SerializedSCT sct;\r\n    TrustAnchorIdentifier trust_anchor;\r\n} SCTTrustAnchorPair;\r\n\r\nSCTTrustAnchorPair SCTTrustAnchorPairList<1..2^16-1>;\r\n```\r\n\r\nNext, we make the trust anchors extension slightly richer. The client can send something like \"I want one of these, two of these, one of these\", etc. The server's advertisement should also be more structured (list of lists of trust anchors), because it needs to communicate \"I have one credential with proofs from A, B, C, another credential with proofs from C, D, E, and another with proofs from D, E, F\".\r\n\r\n\r\n```\r\n// The client's half:\r\nstruct {\r\n    // Semantics: please give me some request_count of trust_anchors\r\n    uint8 request_count;\r\n    TrustAnchorIdentifier trust_anchors<1..2^16-1>;\r\n} TrustAnchorRequest;\r\n\r\n// Semantics: please satisfy *all* of these requests\r\nTrustAnchorRequest TrustAnchorRequestList<1..2^16-1>;\r\n\r\n// The server's half:\r\nstruct {\r\n    // Semantics: I have a credential with associated proofs from each of these trust anchors.\r\n    TrustAnchorIdentifier trust_anchors<1..2^8-1>;\r\n} AvailableCredential;\r\n\r\n// Semantics: I have each of these credentials available.\r\nAvailableCredential AvailableCredentialList<1..2^16-1>;\r\n```\r\n\r\nWe can also go with a more bespoke SCT design, but the nice thing about this it enables other credential types (X.509 is very bad at it) to also have separately negotiable sub-parts.",
      "createdAt": "2024-07-25T20:27:14Z",
      "updatedAt": "2024-09-27T19:54:55Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "body": "struct {\r\n    SerializedSCT sct;\r\n    TrustAnchorIdentifier trust_anchor;\r\n} SCTTrustAnchorPair;\r\n\r\nThis should probably also include an identifier for the log as well, should it not? so that a client can request that is wants one or more SCT from [Frank, George, Festus], so the server can pick from [Frank, Festus, Google, Filippo] that is has? \r\n\r\nAhh, I see the TAI in here is implictly the log's identifer.. nvm. ",
          "createdAt": "2024-09-27T19:37:59Z",
          "updatedAt": "2024-09-27T19:39:29Z"
        },
        {
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "body": "There's a slight problem with Available Credential I think. let's say I have a variety of certificates. certificte from CA A logs to [Fred / Sam]. certificate B logs to [Google / Filippo]. -  This server would advertise credentials from [A, B, Fred, Sam, Google, Flippo] - and a client would be therefore free to ask for (1, (B)) (1, (Fred, Sam))  - not having any clue the server can't give them that.",
          "createdAt": "2024-09-27T19:46:51Z",
          "updatedAt": "2024-09-27T19:46:51Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "In your example, the server would send [[A, Fred, Sam], [B, Google, Filippo]]. That is the point of AvailableCredential, to express which things are associated. :-p",
          "createdAt": "2024-09-27T19:53:30Z",
          "updatedAt": "2024-09-27T19:53:30Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> Ahh, I see the TAI in here is implictly the log's identifer.. nvm.\r\n\r\nYes.",
          "createdAt": "2024-09-27T19:54:54Z",
          "updatedAt": "2024-09-27T19:54:54Z"
        }
      ]
    },
    {
      "number": 62,
      "id": "I_kwDOKigz-s6Q_n5I",
      "title": "Allow one certificate path to match multiple trust anchor IDs",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/issues/62",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "trust-anchor-ids"
      ],
      "body": "See the discussion beginning https://github.com/davidben/merkle-tree-certs/issues/80#issuecomment-2252439958. In looking at rebasing MTCs atop this, we realized that MTCs, since it induces many many individual trust anchors, will effectively only be deployable with the DNS mechanism.\r\n\r\nI think this isn't the end of the world, as MTCs are sufficiently long term that we may have gotten the DNS bits to work. But the original design sketch in MTCs had an extra component. Every certificate had not just an actual trust anchor ID but also a list of trust anchor aliases that also matched it.\r\n\r\nEssentially we were saying that [as long as the certificate isn't expired], any relying party that trusts this other ID can also be assumed to trust this ID. This is kind of a weird scenario for X.509 CAs, but it exactly fits the invariant for MTCs: a client that knows batch number 42 can be assumed to also know batch number 41, 40, etc., down to whatever batches have since expired.\r\n\r\nWe also don't have to do this in this draft and can instead introduce it in the MTCs draft. But it is a little tidier if we do it in the main one.\r\n\r\n(Design history: These aliases eventually grew into trust stores in trust expressions, but got those a lot more complicated to accommodate trust stores changing over time. The trust anchor IDs design tries to avoid that with the retry + DNS dance.)",
      "createdAt": "2024-07-26T16:47:13Z",
      "updatedAt": "2024-12-14T19:25:14Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "CC @bwesterb ",
          "createdAt": "2024-07-26T16:47:42Z",
          "updatedAt": "2024-07-26T16:47:42Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Triaging bugs: I think this is purely orthogonal to what's in the draft. Mechanically, what we'd do is say that a certificate has a list of trust anchor IDs, which would suggest changing the certificate property...\r\n\r\n...except that we really want a single canonical ID for the server to put into DNS and EncryptedExtensions. So any design like this would necessary look like a `trust_anchor_identifier`  property and a separate `additional_trust_anchor_identifiers` property. So this truly can be added later when/if we get interested.",
          "createdAt": "2024-12-14T19:25:13Z",
          "updatedAt": "2024-12-14T19:25:13Z"
        }
      ]
    },
    {
      "number": 63,
      "id": "I_kwDOKigz-s6RIkpc",
      "title": "What is the rationale for allowing handshake failure when no anchors match?",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/issues/63",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "trust-anchor-ids"
      ],
      "body": "> If no certification paths satisfy either extension, the subscriber MAY return a `handshake_failure` alert\r\n\r\nAn alternative would be to mandate that the subscriber always needs to respond with some certificate and its trust anchors as described in \u00a74.3. What is the advantage of the former? There is a clear disadvantage: a client might actually support a trust anchor that the subscriber has available, but it might not have sent it, due to size or privacy constraints.",
      "createdAt": "2024-07-29T09:40:28Z",
      "updatedAt": "2024-12-14T19:11:39Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Sending _something_ requires an explicit choice of fallback certificate somewhere, and the server might not have configured one. The intention was that, whether you send a `handshake_failure` or a certificate, the EncryptedExtensions message still comes in and triggers the retry.\r\n\r\n(This will be moot if we do #53)",
          "createdAt": "2024-07-29T11:54:13Z",
          "updatedAt": "2024-07-29T11:54:13Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "NONE",
          "body": "> The intention was that, whether you send a `handshake_failure` or a certificate, the EncryptedExtensions message still comes in and triggers the retry.\r\n\r\nThat intention would work. I don't see that in the text now, and I could imagine an implementor just failing early with `handshake_failure` without sending `EncryptedExtensions`.\r\n\r\n> Sending something requires an explicit choice of fallback certificate somewhere, and the server might not have configured one.\r\n\r\nWhen would this happen? That means the server also doesn't know what to send if the client doesn't send any trust anchors.",
          "createdAt": "2024-07-29T12:02:07Z",
          "updatedAt": "2024-07-29T12:02:07Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> That intention would work. I don't see that in the text now, and I could imagine an implementor just failing early with handshake_failure without sending EncryptedExtensions.\r\n\r\nHmm. I went to write this down, but it's actually kinda tricky. In fact the natural way to implement this in BoringSSL _would_ actually fail to send EncryptedExtensions because we don't proceed with the handshake until we know which credential we're acting as.\r\n\r\nThis may require some more thought. Or perhaps we end up with #53 and it doesn't matter. Or maybe we just say you really gotta pick a fallback credential. (Provided you have _some_ credential that satisfies sigalgs and other rules. If you don't, a fatal error without retry is fine because no trust anchors would have worked anyway.)",
          "createdAt": "2024-12-14T19:11:39Z",
          "updatedAt": "2024-12-14T19:11:39Z"
        }
      ]
    },
    {
      "number": 64,
      "id": "I_kwDOKigz-s6RJEYF",
      "title": "How much could we compress the list of trust anchors?",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/issues/64",
      "state": "OPEN",
      "author": "bwesterb",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "trust-anchor-ids"
      ],
      "body": "I do not think clients should send a lot of trust anchors. Nor do I think we should complicate the standard with a compression mechanism like this. It's good to think about though.\r\n\r\n### Coding subsets of integers\r\n\r\n#### Theoretical limit\r\nFor the moment, let's simplify and assume trust anchors are numbers instead of OIDs. Say there are k=200 anchors with maximum value N=62,203 (number of PENs today). There are N *choose* k possible subsets of anchors to communicate. Thus, we cannot expect to code every subset with less than lg N choose k bits. We can approximate this well using [Stirling's approximation](https://en.wikipedia.org/wiki/Stirling%27s_approximation): 243 bytes.\r\n\r\n#### Rice coding\r\nWe can get quite close to this limit using a very simple method: [Rice coding](https://en.wikipedia.org/wiki/Golomb_coding) of differences. For each delta we compute *q = floor(d / 2^b)* and *r = d mod 2^b*, where *b = round(-lg(-lg(1-k/N))) = 8*. *q* is encoded in unary and *r* in binary, so 600 would be encoded as `0b11001011000`. The `110` encodes *q=2*; the remainder is the remainder *r*. The average size using Rice coding for random subsets is about 244.3 bytes with a 95th percentile of 244.8 bytes.\r\n\r\nRice coding doesn't take advantage of big gaps. If we want to code *{N-200, N-199, ..., N-1}* that takes 255.25 bytes.\r\n\r\n#### Huffman bitlength\r\nA different approach is to write each delta in two parts: first code its bitlength, and then to write the delta (without its most significant bit). For the bitlengths we can use a Huffman code, which can be compressed efficiently using canonical trees and delta coding of the code lengths as in bzip2. (Here is [an implementation](https://github.com/bwesterb/go-ncrlite).)\r\n\r\nFor random subsets this performs worse than Rice coding: 253 bytes on average with a 95th percentile of 255 bytes. However, it encodes *{N-200, N-199, ..., N-1}* in only 50 bytes, and there is room for improvement.\r\n\r\n\r\n\r\n",
      "createdAt": "2024-07-29T10:43:49Z",
      "updatedAt": "2024-12-17T14:32:42Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Another goofy encoding idea I had was just ranges. The old MTC scheme could be done with aliases on the issuance side (\"if the client says batch 27, assume they also know batches 10 through 26\"), but it could also be done by letting you efficiently encode things like `32473.123.{10-27}` (`32473.123` is the MTC CA prefix).\r\n\r\nI could also imagine taking some of the goofy exclusion labels that TE had and instead recasting them as some kind of sequence of ranges. If we assume we don't need to punch too many holes, splitting ranges in two isn't horrible. And you could periodically rebalance by numbers by allocating new aliases higher up the number space, trusting that newer certs are aware of it. Not sure.\r\n\r\nThe DNS mechanism does handily remove the need for all these encoding tricks, but depends on DNS, so... \ud83e\udd37 ",
          "createdAt": "2024-08-27T21:17:15Z",
          "updatedAt": "2024-08-27T21:17:15Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "NONE",
          "body": "I wanted to add a few more remarks here.\r\n\r\n**Rule of thumb for size.** It's not quite exact, but for N reasonably larger than k, the theoretical best average is approximately k * lg(N/k) bits to encode a random subset of k integers below N. So the number of bits per integer is directly related to the density: lg(N/k) = -lg(k/N).\r\n\r\n**Varying densities.** Most compression mechanisms (including [ncrlite](https://github.com/bwesterb/go-ncrlite/)) adapt to varying densities. If we assume the PENs used in MTC to be in the final quarter of the range, then it'd take only approximately 159 bytes to encode instead of 244.8 b.\r\n\r\n**Encoding actual TAIs instead of integers.** A subset of integers can be seen as a list or as a bitmap. We can encode a set X of true TAIs as a subset of integers Enc(X) as follows. First we group the TAIs by their first component: write n, x_1, ..., x_n, X_1, ..., X_n, L such that X = x_1 . X_1 union x_2 . X_2 union ... union x_n . X_n cup L, where x_i are distinct (the components that appear), L is a set of integers (the components as is that appear as a TAI), and X_i are sets of relative OIDs.\r\n\r\nNow, we can define\r\n\r\n```\r\nBitmap(Enc(X)) = VarUint(n) \r\n      || Bitmap({x_1, ..., x_n})\r\n      || Bitmap({i; 1 \u2264 i \u2264 n; x_i in L})\r\n      || Bitmap(Enc(X_1)) || ... || Bitmap(Enc(X_n))\r\n```\r\n\r\nI guess in practice TAIs will be mostly `<pen>` or `<pen>.<small number>`. In that case I expect this to compress about bit worse but not that much worse than a simply a subset of pens. I can run some tests later.\r\n\r\nIs the full hierarchical TAI worth it though? Isn't `<pen>.<seqno>` enough?\r\n\r\n**Tailored versus general purpose compression**. [ncrlite](https://github.com/bwesterb/go-ncrlite), Elias\u2013Fano, and the like outperform general-purpose compression algorithms when compressing the subset represented as a list of numbers. If the subset is represented as a bitmap, then general-purpose compression algorithms are quite similar or outperform them in compressed size. The difference of course is that we don't want to deal with a huge uncompressed bit map. Further advantages of the former are simpler implementation and better decompression speed.",
          "createdAt": "2024-12-17T13:25:02Z",
          "updatedAt": "2024-12-17T14:32:42Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> Is the full hierarchical TAI worth it though? Isn't . enough?\r\n\r\nEh the only thing we *really* get out of the hierarchy is a cute solution to the MTC batch naming problem. Beyond that, it was just a very convenient, pre-existing namespace of short identifiers that anyone can assign out of.",
          "createdAt": "2024-12-17T14:07:33Z",
          "updatedAt": "2024-12-17T14:07:33Z"
        }
      ]
    },
    {
      "number": 65,
      "id": "I_kwDOKigz-s6R6z06",
      "title": "Trust anchor identifier is limited to 255 bytes",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/issues/65",
      "state": "CLOSED",
      "author": "bwesterb",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "trust-anchor-ids"
      ],
      "body": "If defined as a relative OID to PEN, then the maximum length is 610 bytes (128-6 max depth times 5 bytes for 2^32-1). Implicitly, you restrict to 255 bytes by its TLS encoding. Better make that requirement explicit in \u00a73 or lift it.",
      "createdAt": "2024-08-05T09:47:42Z",
      "updatedAt": "2024-08-12T17:16:09Z",
      "closedAt": "2024-08-12T17:16:09Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure OIDs are actually limited, in either depth or component size. Implementations often apply limits for practicality and DoS, but my understanding was that the data type itself is unbounded.\r\n\r\nTLS doesn't really do variable-length length prefixes, and keeping the length prefix at 1 byte is useful, so I don't think we should raise the limit. Also if you get anywhere near 255 bytes, you're probably doing something wrong. But yeah, we could include a sentence to the effect of \"there's a protocol limit in TLS of 255 bytes but really you shouldn't get anywhere close to this\".",
          "createdAt": "2024-08-05T13:35:53Z",
          "updatedAt": "2024-08-05T13:35:53Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "NONE",
          "body": "You're right\u00a0\u2014 the limit quoted is SMIv2.",
          "createdAt": "2024-08-05T14:25:42Z",
          "updatedAt": "2024-08-05T14:25:42Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "https://github.com/davidben/tls-trust-expressions/pull/66",
          "createdAt": "2024-08-11T23:50:35Z",
          "updatedAt": "2024-08-11T23:50:35Z"
        }
      ]
    },
    {
      "number": 74,
      "id": "I_kwDOKigz-s6YxZTf",
      "title": "Rename \"subscriber\" to \"authenticating party\"",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/issues/74",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We took \"subscriber\" from the BRs but it's referring to a subscriber/applicant to the CA. That's not wrong but is a little confusing in the context of this protocol.\r\n\r\n\"Relying party\" and \"authenticating party\", while a mouthful, has a nice symmetry to it.",
      "createdAt": "2024-10-03T04:17:45Z",
      "updatedAt": "2024-10-03T15:45:46Z",
      "closedAt": "2024-10-03T15:45:46Z",
      "comments": [
        {
          "author": "devonobrien",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 to moving off subscriber and onto authenticating party, even if it is a mouthful. This will undoubtedly get re-litigated post-adoption, so we should just get onto a terminology that's less actively confusing than subscriber.",
          "createdAt": "2024-10-03T13:03:13Z",
          "updatedAt": "2024-10-03T13:03:13Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Haha, I see we previously wrote this, which \"authenticating\" in the other direction. (I'll just rephrase this.)\r\n\r\n> Subscriber: : The party whose identity is being validated in the protocol. In TLS, this is the side sending the Certificate and CertificateVerify message.\r\n>\r\n> Relying party: : The party authenticating the subscriber. In TLS, this is the side that validates a Certificate and CertificateVerify message.",
          "createdAt": "2024-10-03T13:15:31Z",
          "updatedAt": "2024-10-03T13:15:31Z"
        }
      ]
    },
    {
      "number": 76,
      "id": "I_kwDOKigz-s6aQNbd",
      "title": "Adaptions to supersede `server/client_certificate_type` extensions",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/issues/76",
      "state": "CLOSED",
      "author": "pohlm01",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "[Merkle Tree Certificates](https://datatracker.ietf.org/doc/html/draft-davidben-tls-merkle-tree-certs-03) require the `trust_anchors` extension defined in this repository, as well as the `server_certificate_type` and `client_certificate_type` extensions defined in [RFC 7250](https://datatracker.ietf.org/doc/html/rfc7250) (raw public keys).\r\n\r\nThe current draft says:\r\n> If the subscriber sends a certification path that matches the relying party\u2019s trust_anchors extension, as described in [Section 4.2](https://datatracker.ietf.org/doc/html/draft-beck-tls-trust-anchor-ids-01#certificate-selection), the subscriber MUST send an empty trust_anchors extension in the first CertificateEntry of the Certificate message.\r\n\r\nIf we change this to include the selected Trust Anchor instead, we would implicitly negotiate the certificate type as well and leave out the `server_certificate_type` and `client_certificate_type` extensions.\r\nI considered the following scenarios:\r\n\r\n- For negotiating the server certificate type, the client sends the supported Trust Anchors, possibly covering multiple certificate types such as X509 and Bikeshed. The server sends back the selected trust anchor (if match found) as `trust_anchors` extension, with exactly one entry in the first `CertificateEntry` of the `Certificate` message. \r\n  (As an optimization, we could introduce a separate extension only to be used in the `CertificateEntry` message that always contains exactly one entry. This would save two bytes for the length encoding.)\r\n- For negotiating the client certificate type, the server sends the supported Trust Anchors in the `CertificateRequest` message and would again retrieve the selected one as part of the `Certificate` message.\r\n\r\nThis approach has a few implications:\r\n- We need to have a unified representation of the certificate data in the `CertificateEntry` message to allow the application to interpret the data after it processed the extensions. See https://github.com/davidben/merkle-tree-certs/pull/95\r\n- It does increase the size of the extension placed in the `CertificateEntry` message, as it transmits the TAI instead of an empty extension. We could think of sending the TAI only for certificate types that are not X509, but that might complicate things.\r\n- It aligns server and client certificate type negotiation and therefore solves client certificate negotiation identified as a difficulty in [Merkle Tree Certificates](https://datatracker.ietf.org/doc/html/draft-davidben-tls-merkle-tree-certs-03#appendix-B)",
      "createdAt": "2024-10-15T07:49:16Z",
      "updatedAt": "2025-01-27T08:46:47Z",
      "closedAt": "2024-10-23T11:50:55Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Hmm. This does fall somewhat naturally from reusing the same TAI namespace between X.509 and Bikeshed (for completeness, we could have decided to just have a separate `bikeshed_trust_anchors` extension), but I suspect tying certificate format to trust anchor negotiation quite this tightly might be a bit too restrictive:\r\n\r\n* We might end up with multiple negotiation mechanisms. I mean, I hope not, but we already had two points in the trade-off space and #64 explores another one.\r\n* TAI's current design allows for the server to guess and for the client to retry if it's not happy. But if I see an unknown TAI, how do I know whether to check the contents (maybe it's an X.509 chain that I accept anyway) or not (maybe it's some non-X.509 format altogether)\r\n* For X.509, the relying party may have trust anchors that don't participate in TAI, either for privacy reasons or because there just isn't a TAI allocated. That's unlikely for Merkle Tree Certificates due to its strong dependency on negotiation, but maybe other bikeshed proof types or other cert formats will care.\r\n\r\nSo I suspect it'll be simplest if we keep the type explicit.",
          "createdAt": "2024-10-21T16:42:47Z",
          "updatedAt": "2024-10-21T16:42:47Z"
        },
        {
          "author": "pohlm01",
          "authorAssociation": "NONE",
          "body": "Yes, you are right. Especially the second point seems quite relevant to me.",
          "createdAt": "2024-10-23T11:50:55Z",
          "updatedAt": "2024-10-23T11:50:55Z"
        }
      ]
    },
    {
      "number": 79,
      "id": "I_kwDOKigz-s6iVjan",
      "title": "Move ACME extension from TAI to its own draft",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/issues/79",
      "state": "CLOSED",
      "author": "devonobrien",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "trust-anchor-ids"
      ],
      "body": "The ACME extension defined in Section 6 might be better defined in its own draft and submitted to the ACME wg.",
      "createdAt": "2024-12-06T17:21:01Z",
      "updatedAt": "2024-12-14T19:20:55Z",
      "closedAt": "2024-12-14T19:20:54Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "This is done, or rather the ACME extension is simplified to just MIME type stuff, per @aarongable's feedback.",
          "createdAt": "2024-12-14T19:20:54Z",
          "updatedAt": "2024-12-14T19:20:54Z"
        }
      ]
    },
    {
      "number": 91,
      "id": "I_kwDOKigz-s6pemiT",
      "title": "Clarify meaning of empty trust_anchors extensions",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/issues/91",
      "state": "OPEN",
      "author": "bob-beck",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "trust-anchor-ids"
      ],
      "body": "\nCurrently if the client examines a list of TAI's for a server (either via DNS SVCB, previous Encrypted Extensions, or any yet to be determined means) we do not say what the client should do as a result. \n\nIf the client decides it does not have a common intersection with this list it is free to:\n\nA) send an empty TAI extension, and hope the other end sends it updated information where it might now have an option\nB) send no TAI extension, to force the other end to do their legacy behaviour, relying on being able to path build it's way to an ubiquitious trust anchor from what the server sends it in the fallback case. \n\nIf a *server* decides for whatever reason to not advertise a full list of trust anchors, It can not rely on the client retrying if the client decides to fall back to the legacy behaviour. \n\nNot sure if this is fine, or not. ",
      "createdAt": "2025-02-10T19:07:07Z",
      "updatedAt": "2025-02-23T16:06:19Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we should be opinionated and the answer should be yes, just send an empty one.",
          "createdAt": "2025-02-10T19:20:21Z",
          "updatedAt": "2025-02-10T19:20:21Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "In particular, the server is already expected to do something sensible in response to the empty list. That could be the default lowest common denominator credential, or a slightly more aggressive one targeting the common case, with the knowledge that the retry will work. This was a key point in the current design, to make the DNS bits slightly less load bearing.",
          "createdAt": "2025-02-10T19:25:27Z",
          "updatedAt": "2025-02-10T19:25:27Z"
        }
      ]
    },
    {
      "number": 92,
      "id": "I_kwDOKigz-s6q4uAp",
      "title": "s/trust anchor identifier/trust anchor ID/g",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/issues/92",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "trust-anchor-ids"
      ],
      "body": "I suspect \"identifier\" came out of preemptive adherence to the style preference to expand acronyms, but surely ID is a well known enough acronym. (Or we can call it \"trust anchor identifier (trust anchor ID)\" the first time and move on.\n\nMostly I would like to have an \"official\" short-ish phrase so we stop being tempted to use \"TAI\" in more formal contexts like API names.",
      "createdAt": "2025-02-20T18:44:32Z",
      "updatedAt": "2025-02-20T18:44:51Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 2,
      "id": "PR_kwDOKigz-s5dapOK",
      "title": "Slightly tweak the intro",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/2",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Rereading it, that sentence was a little long and hard to parse. Also the third bullet is kinda redundant with it, so remove it. That also cleans things up because we talk about costs to CAs, subscribers, and RPs, and then have one bullet for each in order.",
      "createdAt": "2023-10-20T19:46:17Z",
      "updatedAt": "2023-10-21T02:07:31Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "bcf0fea1e62016c8e1dd4a981fa1a52db2b36a42",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "intro-tweak",
      "headRefOid": "f5726eb7b712a70bda58e0677790b198c98bf4b0",
      "closedAt": "2023-10-20T23:26:37Z",
      "mergedAt": "2023-10-20T23:26:37Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "0c61ee50d9ee04897ab093ef27ffa43be9827ee0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s5kyVR6",
          "commit": {
            "abbreviatedOid": "f5726eb"
          },
          "author": "devonobrien",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-20T21:21:12Z",
          "updatedAt": "2023-10-20T21:21:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 5,
      "id": "PR_kwDOKigz-s5lAEZA",
      "title": "Rework the privacy considerations section",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/5",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bob-beck"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2024-01-24T21:53:12Z",
      "updatedAt": "2024-01-25T17:17:05Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "a00613b25482bd0d7a3ab418fe8bf9f38691559e",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "privacy-considerations",
      "headRefOid": "87ac048c5aa7d001c1585ab44440e62685d0ca99",
      "closedAt": "2024-01-25T17:17:00Z",
      "mergedAt": "2024-01-25T17:17:00Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "e7dcbf6c5d3d70636ecf9507c94a1f61b2b3869b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s5t7Uqv",
          "commit": {
            "abbreviatedOid": "87ac048"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-25T17:16:34Z",
          "updatedAt": "2024-01-25T17:16:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 7,
      "id": "PR_kwDOKigz-s5oVShz",
      "title": "Add an informal explainer document",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/7",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-02-29T19:39:51Z",
      "updatedAt": "2024-02-29T23:44:13Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "11cb5c005a38586963db5eb75f319877adc2ec07",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "explainer",
      "headRefOid": "c964ac14a6337efc8080a07230a8d0ad43411fac",
      "closedAt": "2024-02-29T23:44:11Z",
      "mergedAt": "2024-02-29T23:44:11Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "3c9df037f7e5aa1b58a555c3998356364b2cea07"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s5x1Uwm",
          "commit": {
            "abbreviatedOid": "a0ba6a2"
          },
          "author": "dadrian",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-29T20:24:26Z",
          "updatedAt": "2024-02-29T20:24:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 11,
      "id": "PR_kwDOKigz-s5qcjwg",
      "title": "Remove the trustExpressions extension flag for ACME.",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/11",
      "state": "MERGED",
      "author": "bob-beck",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This has always been an optimization, not a requirement for this to work. Some discussions with CA operators indicate this is probably unnecessary and we can remove it for now.",
      "createdAt": "2024-03-22T05:03:26Z",
      "updatedAt": "2024-03-22T21:50:38Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "abd930a6a0f9961398127ef04c47d3696486f2e8",
      "headRepository": "bob-beck/tls-trust-expressions",
      "headRefName": "main",
      "headRefOid": "e974e4cbb2e1f40ccf623f28028cf4fb58c1e336",
      "closedAt": "2024-03-22T21:50:38Z",
      "mergedAt": "2024-03-22T21:50:38Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "5e02af81a8fb58c90064794f0682a8154cafdd87"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s50fN9G",
          "commit": {
            "abbreviatedOid": "582e853"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-22T09:31:51Z",
          "updatedAt": "2024-03-22T09:31:51Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "We can delete this section heading too.",
              "createdAt": "2024-03-22T09:31:51Z",
              "updatedAt": "2024-03-22T09:31:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s50fOB5",
          "commit": {
            "abbreviatedOid": "582e853"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM!",
          "createdAt": "2024-03-22T09:32:00Z",
          "updatedAt": "2024-03-22T09:32:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 14,
      "id": "PR_kwDOKigz-s5vcRlU",
      "title": "Add a brief discussion about using DNS names to the explainer",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/14",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-05-14T19:12:50Z",
      "updatedAt": "2024-05-14T19:52:07Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "5e02af81a8fb58c90064794f0682a8154cafdd87",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "explainer-dns",
      "headRefOid": "484b35167f6945c287b7781d82a835761a729ab5",
      "closedAt": "2024-05-14T19:52:04Z",
      "mergedAt": "2024-05-14T19:52:04Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "6038f10f4fa16dd9c1fad1b92eeee71a4ff4f489"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s56kEGQ",
          "commit": {
            "abbreviatedOid": "484b351"
          },
          "author": "devonobrien",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-05-14T19:50:49Z",
          "updatedAt": "2024-05-14T19:50:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 15,
      "id": "PR_kwDOKigz-s5wAn1a",
      "title": "Add a couple more sections to the explainer",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/15",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-05-20T22:44:26Z",
      "updatedAt": "2024-05-21T22:03:19Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "6038f10f4fa16dd9c1fad1b92eeee71a4ff4f489",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "explainer-updates",
      "headRefOid": "44398262575ef30d08a66155e5c1717de062e08d",
      "closedAt": "2024-05-21T22:03:16Z",
      "mergedAt": "2024-05-21T22:03:16Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "3837d23bd8d0d6d50b78fdde218d8deb5c6ba03e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s57Noew",
          "commit": {
            "abbreviatedOid": "4439826"
          },
          "author": "devonobrien",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-20T22:57:19Z",
          "updatedAt": "2024-05-20T22:57:32Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "It might be helpful to slightly expand on this point with something to the effect of:\r\n\r\nWebsites that need to function in both CT-enforcing and non-CT-enforcing user agents are required to include several additional SCT signatures with their certificates, regardless of whether they were needed. With the significant leap in size from ECDSA to current PQC algorithms, this becomes a significant challenge that some user agents may opt to require SCT omission, rather than tacitly ignoring them.",
              "createdAt": "2024-05-20T22:57:19Z",
              "updatedAt": "2024-05-20T22:57:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s57WeBL",
          "commit": {
            "abbreviatedOid": "4439826"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-21T19:41:01Z",
          "updatedAt": "2024-05-21T19:41:01Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Hmm. I guess I was viewing this as a brief illustration of how they diverge today (beyond the obvious one of slightly different trusted CAs), with the impact to PQC the next paragraph. Talking about this here doesn't quite flow, but maybe there's another way to organize it?\r\n\r\nThe cost of sending stuff that only some clients care about is roughly covered in the section about cross-signing, though I think that needs a bit more text. SCTs are also an example of this, but maybe less directly to the point since we haven't really discussed CT in the context of trust expressions much yet.\r\n\r\nCould also just delete this paragraph if it's mostly confusing.",
              "createdAt": "2024-05-21T19:41:01Z",
              "updatedAt": "2024-05-21T19:41:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s57XPTp",
          "commit": {
            "abbreviatedOid": "4439826"
          },
          "author": "devonobrien",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-21T21:48:49Z",
          "updatedAt": "2024-05-21T21:48:49Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Yeah, that's fair about it being better suited in another section, but I think it's worth expanding upon somewhere, especially in light of PQC sig sizes adding the risk that relying parties would overlook their presence as they do today. I'm good with the changes.",
              "createdAt": "2024-05-21T21:48:49Z",
              "updatedAt": "2024-05-21T21:48:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s57XPoE",
          "commit": {
            "abbreviatedOid": "4439826"
          },
          "author": "devonobrien",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-05-21T21:50:02Z",
          "updatedAt": "2024-05-21T21:50:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 16,
      "id": "PR_kwDOKigz-s5wZz5r",
      "title": "Discuss the implications of serving certificates from some CA",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/16",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From IETF discussion, it seems there is some confusion about the nature of PKI-based authentication, the implications of serving a correct certificate from an untrustworthy CA, and the roles and goals of subscribers and relying parties in this interaction. There also appears to be some concern of actors using this kind of confusion to convince confused root program operators of inadvisable actions, as well as some discussion amplifying this confusion.\r\n\r\nSpell this out in Security Considerations, in hopes of reducing all this confusion.\r\n\r\nAlso spell out how agility reduces what would otherwise be a strong compatibility vs security conflict. This implication seems to also have been non-obvious to folks.",
      "createdAt": "2024-05-24T03:26:26Z",
      "updatedAt": "2024-05-24T15:39:37Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "3837d23bd8d0d6d50b78fdde218d8deb5c6ba03e",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "pki-roles",
      "headRefOid": "c213d203b457b28d7045297d74cde00a738c3330",
      "closedAt": "2024-05-24T15:39:34Z",
      "mergedAt": "2024-05-24T15:39:34Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "b3d7b31a968b739ab15bb8e809106d46d083600d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s570J-_",
          "commit": {
            "abbreviatedOid": "c213d20"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-05-24T15:38:19Z",
          "updatedAt": "2024-05-24T15:38:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 20,
      "id": "PR_kwDOKigz-s5wg6Fk",
      "title": "Soften the SHOULD for disabling path building in the RP",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/20",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #18.",
      "createdAt": "2024-05-24T21:54:40Z",
      "updatedAt": "2024-05-29T16:03:36Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "b3d7b31a968b739ab15bb8e809106d46d083600d",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "path-building-should-may",
      "headRefOid": "e56f3c4aa353c0b7cbcbe5f192a1349c17fcca88",
      "closedAt": "2024-05-29T16:03:33Z",
      "mergedAt": "2024-05-29T16:03:33Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "315dcb3998a901cfcb2e47a341064dc5bcd243fb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s58Uttf",
          "commit": {
            "abbreviatedOid": "e56f3c4"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-05-29T15:50:34Z",
          "updatedAt": "2024-05-29T15:50:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 21,
      "id": "PR_kwDOKigz-s5wy3Pz",
      "title": "Rewrite subscriber behavior sections",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/21",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #19. The changes made here are:\r\n\r\n1. Don't prescribe an exact selection algorithm. Only prescribe the matching procedure.\r\n\r\n2. Move the expiry check into the matching procedure, because it's part of the process. (Version skew depends on this.)\r\n\r\n3. Although we don't prescribe it, give an example selection algorithm that also incorporates certificate_authorities, in response to feedback. This example is also structured differently, because it more closely aligns with how we anticipate implementing it.",
      "createdAt": "2024-05-28T17:48:51Z",
      "updatedAt": "2024-07-18T21:25:40Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "b3d7b31a968b739ab15bb8e809106d46d083600d",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "selection-algorithm",
      "headRefOid": "717ae7b9ade420e00c6950134b97ed0ff65a6ef6",
      "closedAt": "2024-05-30T17:29:17Z",
      "mergedAt": "2024-05-30T17:29:17Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "a6949a24b24679dafcc848c7aef2400fcc036126"
      },
      "comments": [
        {
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "body": "https://github.com/davidben/tls-trust-expressions/issues/25\r\nand\r\nhttps://github.com/davidben/tls-trust-expressions/issues/26\r\nfell out of this.\r\n",
          "createdAt": "2024-05-30T18:02:16Z",
          "updatedAt": "2024-05-30T18:02:16Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s58Ummy",
          "commit": {
            "abbreviatedOid": "717ae7b"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2024-05-29T15:38:33Z",
          "updatedAt": "2024-05-29T15:43:14Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I don't think we want to do this here.  If for (reasons) my certificates have expired, today, I still serve up the expired certificate rather than effectively, failing. It is then up to the relying party to decide what to do with an expired certificate and this changes that dynamic. \r\n\r\nI think an expired path is *still* a match.  If there is *more than one* match and one is expired and one is not, then absolutely, choose the non-expired one to serve. ",
              "createdAt": "2024-05-29T15:38:33Z",
              "updatedAt": "2024-05-29T15:43:15Z"
            },
            {
              "originalPosition": 11,
              "body": "Consider a future PQ world with PQ clients, and a default classical cert - it's worse behaviour to serve up the classical cert because the PQ cert  that matched the expression was expired, than to just serve up the expired cert we know matches because it's the best we have. ",
              "createdAt": "2024-05-29T15:41:46Z",
              "updatedAt": "2024-05-29T15:43:15Z"
            },
            {
              "originalPosition": 44,
              "body": "I think here is the place to be opinionated over serving non-expired and smallest size paths first. ",
              "createdAt": "2024-05-29T15:43:06Z",
              "updatedAt": "2024-05-29T15:43:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s58VG6v",
          "commit": {
            "abbreviatedOid": "717ae7b"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-29T16:35:22Z",
          "updatedAt": "2024-05-29T16:35:23Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "The problem is that, if expired, all the version skew machinery we've put in no longer works. The relying party only needs to send `excluded_labels` up to when the old certificates expire. If we say that expired certificates may match, then the relying party can never retire `excluded_labels` and then removals leave persistent scar tissue.",
              "createdAt": "2024-05-29T16:35:22Z",
              "updatedAt": "2024-05-29T16:35:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s58Vco6",
          "commit": {
            "abbreviatedOid": "717ae7b"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-29T17:19:21Z",
          "updatedAt": "2024-05-29T17:19:21Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "although I suspect that may come down to picking the newer of the smallest... ",
              "createdAt": "2024-05-29T17:19:21Z",
              "updatedAt": "2024-05-29T17:19:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s58gUyu",
          "commit": {
            "abbreviatedOid": "717ae7b"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-30T16:51:25Z",
          "updatedAt": "2024-05-30T16:51:25Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "After conversation offline, I'm maybe kinda ok with this, as long as we call out the new dependency on the server having accurate time, which I think we need to note, as well as the differences here that we would noa serve the default cert in this case instead of the expired one in some situations. ",
              "createdAt": "2024-05-30T16:51:25Z",
              "updatedAt": "2024-05-30T16:51:25Z"
            }
          ]
        }
      ]
    },
    {
      "number": 22,
      "id": "PR_kwDOKigz-s5wziv2",
      "title": "Clarify that the bad certificates may come in the future too",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/22",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-05-28T19:56:31Z",
      "updatedAt": "2024-05-29T16:04:15Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "b3d7b31a968b739ab15bb8e809106d46d083600d",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "also-future-signing",
      "headRefOid": "66bddbce24cf6f060498d93a3f9a959caec620e5",
      "closedAt": "2024-05-29T16:04:12Z",
      "mergedAt": "2024-05-29T16:04:12Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "80147015906458dfb7d10980d1a1141ac31e1b6a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s58Uj9n",
          "commit": {
            "abbreviatedOid": "66bddbc"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-05-29T15:33:51Z",
          "updatedAt": "2024-05-29T15:33:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 24,
      "id": "PR_kwDOKigz-s5w4aZh",
      "title": "Say this is for TLS 1.3 or later",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/24",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #4",
      "createdAt": "2024-05-29T12:48:08Z",
      "updatedAt": "2024-05-29T16:04:04Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "b3d7b31a968b739ab15bb8e809106d46d083600d",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "tls13",
      "headRefOid": "fb05ddd54b443071681e761c108de05c0076ffd9",
      "closedAt": "2024-05-29T16:04:01Z",
      "mergedAt": "2024-05-29T16:04:01Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "17e316cc387c2ccfc5844ec68676cf7e89f9c9d7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s58Ujl4",
          "commit": {
            "abbreviatedOid": "fb05ddd"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-05-29T15:33:12Z",
          "updatedAt": "2024-05-29T15:33:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 27,
      "id": "PR_kwDOKigz-s5xEU2Q",
      "title": "Add explainer sections for server software and cert provisioning changes we expect. ",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/27",
      "state": "MERGED",
      "author": "bob-beck",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-05-30T23:45:58Z",
      "updatedAt": "2024-06-06T21:37:12Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "a6949a24b24679dafcc848c7aef2400fcc036126",
      "headRepository": "bob-beck/tls-trust-expressions",
      "headRefName": "main",
      "headRefOid": "b12e05dbbbf46cd922dd831e2a0e0575f64f4399",
      "closedAt": "2024-06-06T21:37:12Z",
      "mergedAt": "2024-06-06T21:37:11Z",
      "mergedBy": "bob-beck",
      "mergeCommit": {
        "oid": "04d8bcc23638aa8603d4aedb18eb160d449ac2f8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s58q2ML",
          "commit": {
            "abbreviatedOid": "34fb123"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-31T19:46:44Z",
          "updatedAt": "2024-05-31T19:46:44Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Nit, just to match the casing of the other sections.\r\n```suggestion\r\n## Server Software Changes\r\n```",
              "createdAt": "2024-05-31T19:46:44Z",
              "updatedAt": "2024-05-31T19:46:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s58q2Xp",
          "commit": {
            "abbreviatedOid": "34fb123"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM, although I'm a little confused why GitHub seems to think a bunch of other commits are part of your PR. Wonder if you need to rebase or something?",
          "createdAt": "2024-05-31T19:47:14Z",
          "updatedAt": "2024-05-31T19:47:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 29,
      "id": "PR_kwDOKigz-s5yJ0Jw",
      "title": "Add a discussion of server operator burden to the explainer",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/29",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "devonobrien",
        "bob-beck"
      ],
      "labels": [],
      "body": "Possibly some of this should graduate to the draft too.",
      "createdAt": "2024-06-11T19:59:25Z",
      "updatedAt": "2024-06-17T19:07:08Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "04d8bcc23638aa8603d4aedb18eb160d449ac2f8",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "server-operator-burden",
      "headRefOid": "bd10f57d5c66b36820bed5293a74d6096363dc71",
      "closedAt": "2024-06-17T19:07:05Z",
      "mergedAt": "2024-06-17T19:07:05Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "0c2822ebaa411ed32e2266b41265455b2009b47c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s59_Uny",
          "commit": {
            "abbreviatedOid": "8d0a316"
          },
          "author": "devonobrien",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2024-06-12T18:06:40Z",
          "updatedAt": "2024-06-12T18:13:16Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Since we're not spending much time on this topic, I think we should also point out the technical limitations. Fingerprinting is relatively unreliable because it's an inferred signal and collecting intermediates requires constant curation to remain relevant. Maybe something like:\r\n\"they are impractical for a more diverse set of HTTPS servers and are limited in both the types of signals available and the reliability of those signals.\"\r\n",
              "createdAt": "2024-06-12T18:06:40Z",
              "updatedAt": "2024-06-12T18:13:16Z"
            },
            {
              "originalPosition": 36,
              "body": "Possibly \"shift work from server operators to CAs and root programs\" to make the shift more explicit",
              "createdAt": "2024-06-12T18:08:42Z",
              "updatedAt": "2024-06-12T18:13:16Z"
            },
            {
              "originalPosition": 45,
              "body": "What does certificate profile mean here? In PKI terms, this usually refers to the issuance template for a given certificate, but I think this is referring to changes in trust for a given certificate?",
              "createdAt": "2024-06-12T18:11:52Z",
              "updatedAt": "2024-06-12T18:13:16Z"
            },
            {
              "originalPosition": 42,
              "body": "This last point is worth including, but the text leans further into a narrow example than I would have expected from the title. Is there a broader point here we can focus on? I don't have a strong suggestion here, but there seems to be an opportunity to make a stronger point here.",
              "createdAt": "2024-06-12T18:12:46Z",
              "updatedAt": "2024-06-12T18:13:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s5-LCww",
          "commit": {
            "abbreviatedOid": "8d0a316"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-13T20:16:16Z",
          "updatedAt": "2024-06-13T21:12:26Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "We do spend time on the topic, just elsewhere in the document. I can add a \"see elsewhere\" sentence.",
              "createdAt": "2024-06-13T20:16:16Z",
              "updatedAt": "2024-06-13T21:12:27Z"
            },
            {
              "originalPosition": 45,
              "body": "This is talking about server operators (\"from the server operator's perspective\"), so it refers to a change to the kind of certificates they serve. I don't want to say a change in the exact certificates, because that happens routinely. Rephrased to avoid the phrase.",
              "createdAt": "2024-06-13T20:16:46Z",
              "updatedAt": "2024-06-13T21:12:27Z"
            },
            {
              "originalPosition": 36,
              "body": "Done.",
              "createdAt": "2024-06-13T20:16:57Z",
              "updatedAt": "2024-06-13T21:12:27Z"
            },
            {
              "originalPosition": 42,
              "body": "I tried to generalize this but honestly it made it even harder to follow. This already tells a pretty general story; any time server operators are required to make some change, we should reduce any unnecessary risks that they have to take on. But I think it's important to talk about compromised CA as the motivating example because that's what makes it about incident response.\r\n\r\nRephrased it a bit to make it clear the CA compromise is just an example.",
              "createdAt": "2024-06-13T20:23:33Z",
              "updatedAt": "2024-06-13T21:12:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s5-lQ7O",
          "commit": {
            "abbreviatedOid": "bd10f57"
          },
          "author": "devonobrien",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "The changes LGTM. Thanks for the tweaks.",
          "createdAt": "2024-06-17T19:01:34Z",
          "updatedAt": "2024-06-17T19:01:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 30,
      "id": "PR_kwDOKigz-s5yboQk",
      "title": "Use PENs to allocate trust store names",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/30",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "devonobrien",
        "bob-beck"
      ],
      "labels": [],
      "body": "This gives a concrete allocation scheme, is compact, and also aligns well with some plans we have around Merkle Tree Certificates.",
      "createdAt": "2024-06-14T03:35:45Z",
      "updatedAt": "2024-06-14T18:01:51Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "04d8bcc23638aa8603d4aedb18eb160d449ac2f8",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "oid",
      "headRefOid": "8d04679c4194afcd34a8ad5d8919b11d9cfd6c1b",
      "closedAt": "2024-06-14T18:01:45Z",
      "mergedAt": "2024-06-14T18:01:45Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "d20509e10cec37724981594c38725ab61957eaa4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s5-Sadl",
          "commit": {
            "abbreviatedOid": "8d04679"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-14T16:20:31Z",
          "updatedAt": "2024-06-14T16:20:32Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "in text form as desribed in {{trust-store-ids}}}",
              "createdAt": "2024-06-14T16:20:31Z",
              "updatedAt": "2024-06-14T16:20:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s5-SbOf",
          "commit": {
            "abbreviatedOid": "8d04679"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-14T16:22:20Z",
          "updatedAt": "2024-06-14T16:22:20Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "s/binary/der/",
              "createdAt": "2024-06-14T16:22:20Z",
              "updatedAt": "2024-06-14T16:22:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s5-SbdD",
          "commit": {
            "abbreviatedOid": "8d04679"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-14T16:22:53Z",
          "updatedAt": "2024-06-14T16:22:53Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKigz-s5-S1Dt",
          "commit": {
            "abbreviatedOid": "8d04679"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-14T16:51:20Z",
          "updatedAt": "2024-06-14T16:51:20Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Oh, this isn't an OID. Those are used to name the trust stores. This is an index into the `trust_anchors` object. (That part of the design also maybe needs work, but we're not doing anything with it just yet.)",
              "createdAt": "2024-06-14T16:51:20Z",
              "updatedAt": "2024-06-14T16:51:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s5-S1bT",
          "commit": {
            "abbreviatedOid": "8d04679"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-14T16:52:22Z",
          "updatedAt": "2024-06-14T16:52:22Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "trust-store-ids refers to it as \"binary\". I didn't want to say DER because then we have to clarify whether the tag and length are included. (They're not.) So trust-store-ids defines it once by name and we reference it.",
              "createdAt": "2024-06-14T16:52:22Z",
              "updatedAt": "2024-06-14T16:52:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s5-TN83",
          "commit": {
            "abbreviatedOid": "8d04679"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-14T17:58:25Z",
          "updatedAt": "2024-06-14T17:58:25Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "Yeah, let's not create more of the dreaded 20 octets fun. ",
              "createdAt": "2024-06-14T17:58:25Z",
              "updatedAt": "2024-06-14T17:58:25Z"
            }
          ]
        }
      ]
    },
    {
      "number": 31,
      "id": "PR_kwDOKigz-s5yuQWf",
      "title": "Clarify that \"which browser\" can include any browser using the same trust expression. ",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/31",
      "state": "MERGED",
      "author": "bob-beck",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In the Privacy section. \r\n\r\nDiscussion by Dennis Jackson on the mailing lists indicates this seems to be a point of confusion.",
      "createdAt": "2024-06-17T17:41:42Z",
      "updatedAt": "2024-06-18T00:59:06Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "d20509e10cec37724981594c38725ab61957eaa4",
      "headRepository": "bob-beck/tls-trust-expressions",
      "headRefName": "main",
      "headRefOid": "a85ea288b397f2741a0cb0e75737bd9640be977b",
      "closedAt": "2024-06-18T00:59:06Z",
      "mergedAt": "2024-06-18T00:59:06Z",
      "mergedBy": "bob-beck",
      "mergeCommit": {
        "oid": "cef41e4a48fc3604231e5e08628a60d544e70531"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s5-l5WJ",
          "commit": {
            "abbreviatedOid": "280e8b8"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-17T20:39:11Z",
          "updatedAt": "2024-06-17T20:39:11Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I think the discussion at the IETF thread has slightly misrepresented the point of this paragraph. It is not a complete analysis of all web browser scenarios. Rather, it is an illustrative example in service of the point of a Privacy Considerations section: to guide implementors in using the mechanism according to privacy expectations. Given that confusion, I think it's worth rephrasing this a bit to be more clear about the scope. (Trying to do a complete analysis will be very product-specific, and depend on things like frequency of trust store updates, which browsers share root programs, and whether the browser has an out-of-band update process.)\r\n\r\nMaybe something like this?\r\n\r\n```suggestion\r\nFor example, a web browser may support both a common set of trust anchors configured by the browser vendor, along with user-specified additions and removals. Applying the above guidance with a typical browser's desired anonymity set, the trust expression would reflect only the common trust anchors. User-specified modifications may reveal identifying information about the user.\r\n\r\nThis guidance limits the benefits of trust anchor agility in two ways:\r\n```\r\n\r\nI tried to say something about what common trust anchors reveal, but it got really, really long-winded and awkward to cover all bases. WDYT?",
              "createdAt": "2024-06-17T20:39:11Z",
              "updatedAt": "2024-06-17T20:39:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s5-l_DK",
          "commit": {
            "abbreviatedOid": "280e8b8"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-17T20:55:17Z",
          "updatedAt": "2024-06-17T20:55:17Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I tweaked your text a bit. have a look\r\n",
              "createdAt": "2024-06-17T20:55:17Z",
              "updatedAt": "2024-06-17T20:55:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s5-mQ-8",
          "commit": {
            "abbreviatedOid": "4a97eba"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-17T21:48:29Z",
          "updatedAt": "2024-06-17T21:48:30Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "> the trust expression would reflect only the common trust anchors for any web browsers using the same trust expression\r\n\r\nI think this is tautological and doesn't say what we're trying to say. Even if, say, a web browser decided to use the user-specified ones, it would be true that the trust expression only reflects trust anchors common to web browsers that use that trust expression. It's just that there's only one of them.\r\n\r\n\"common trust anchors\" was meant in reference to the first sentence in the paragraph:\r\n\r\n> For example, a web browser may support both a common set of trust anchors configured by a root program, along with user-specified additions and removals",
              "createdAt": "2024-06-17T21:48:29Z",
              "updatedAt": "2024-06-17T21:48:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s5-m5q6",
          "commit": {
            "abbreviatedOid": "4a97eba"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-18T00:40:28Z",
          "updatedAt": "2024-06-18T00:40:28Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I was tryin to sneak in there the notion that it's not just the anonymity set of a single web browser, multiple web browsers could use the same trust expression provided by a root program. ",
              "createdAt": "2024-06-18T00:40:28Z",
              "updatedAt": "2024-06-18T00:40:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s5-m54W",
          "commit": {
            "abbreviatedOid": "4a97eba"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-18T00:41:40Z",
          "updatedAt": "2024-06-18T00:41:40Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Or at least make that somewhat clearer to the reader, on first cut it sounds like the anonymity set is only the browser unless you are very careful reading it",
              "createdAt": "2024-06-18T00:41:40Z",
              "updatedAt": "2024-06-18T00:41:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s5-m8cb",
          "commit": {
            "abbreviatedOid": "4a97eba"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-18T00:56:39Z",
          "updatedAt": "2024-06-18T00:56:39Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "How about this?\r\n\r\n```suggestion\r\nFor example, a web browser may support both a common set of trust anchors configured by a root program, along with user-specified additions and removals. Applying the above guidance with a typical browser's desired anonymity set, the trust expression would reflect only the common trust anchors and not the user-specified modifications. The user-specified modifications may reveal identifying information about the user, while the common trust anchors would reveal at most, e.g., which version of which browser is used, or even less information if multiple browsers share a root program or the trust anchors were unchanged across multiple versions of the browser.\r\n```",
              "createdAt": "2024-06-18T00:56:39Z",
              "updatedAt": "2024-06-18T00:56:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 32,
      "id": "PR_kwDOKigz-s5ywc01",
      "title": "Fix the TrustStoreInclusion for C1_new",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/32",
      "state": "MERGED",
      "author": "devonobrien",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The labels for C1_new should match those specified i the example trust store manifest above.",
      "createdAt": "2024-06-17T23:55:44Z",
      "updatedAt": "2024-06-18T00:45:57Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "0c2822ebaa411ed32e2266b41265455b2009b47c",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "devonobrien-fix-example-c1-new",
      "headRefOid": "7ad11cb9671bfdba89885d4566021ef3c192ab8a",
      "closedAt": "2024-06-18T00:45:48Z",
      "mergedAt": "2024-06-18T00:45:48Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "cf6dd30e82544c844e119a64b9ef55e41c0788fe"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s5-m6je",
          "commit": {
            "abbreviatedOid": "7ad11cb"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-18T00:45:34Z",
          "updatedAt": "2024-06-18T00:45:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 33,
      "id": "PR_kwDOKigz-s5ziGpB",
      "title": "Add a document discussion PKI transition strategies",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/33",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "devonobrien",
        "bob-beck"
      ],
      "labels": [],
      "body": "We'll probably find more topics to discuss here, but this is already long enough to warrant its own document.",
      "createdAt": "2024-06-25T18:16:15Z",
      "updatedAt": "2024-06-25T18:22:08Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "cef41e4a48fc3604231e5e08628a60d544e70531",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "transition-strategies",
      "headRefOid": "d7d9b9ac4d97a309e603a7835550f642c9f06915",
      "closedAt": "2024-06-25T18:22:05Z",
      "mergedAt": "2024-06-25T18:22:05Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "8b2e515a32a0e33da0a6675b3d5e8d5aae15513c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s5_hbIE",
          "commit": {
            "abbreviatedOid": "d7d9b9a"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-25T18:20:45Z",
          "updatedAt": "2024-06-25T18:20:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 34,
      "id": "PR_kwDOKigz-s5zjcS5",
      "title": "Update explainer text a bit",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/34",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "devonobrien"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2024-06-25T22:04:58Z",
      "updatedAt": "2024-06-25T22:24:46Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "8b2e515a32a0e33da0a6675b3d5e8d5aae15513c",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "explainer-update",
      "headRefOid": "f04268d9b8857e0fa3a89699e3264373fd5075bd",
      "closedAt": "2024-06-25T22:24:43Z",
      "mergedAt": "2024-06-25T22:24:43Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "52fb8e3761d26a6d789c0a038808c2771d0991cf"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s5_jYVI",
          "commit": {
            "abbreviatedOid": "f04268d"
          },
          "author": "devonobrien",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for copying my comments over to GH. LGTM!",
          "createdAt": "2024-06-25T22:20:11Z",
          "updatedAt": "2024-06-25T22:20:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 35,
      "id": "PR_kwDOKigz-s5zuMJT",
      "title": "Clarify SCT-based distrust a bit",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/35",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "devonobrien",
        "bob-beck"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2024-06-27T05:38:20Z",
      "updatedAt": "2024-06-27T17:19:55Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "52fb8e3761d26a6d789c0a038808c2771d0991cf",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "sct-distrust-clarify",
      "headRefOid": "37d64921c12a6ed97707c9d64e14f902a39d2423",
      "closedAt": "2024-06-27T17:19:52Z",
      "mergedAt": "2024-06-27T17:19:52Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "0e117cd3de3e50ea14c1d4e7d1a0e766bf19a5b5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s5_5o_6",
          "commit": {
            "abbreviatedOid": "69e40db"
          },
          "author": "devonobrien",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-27T15:49:16Z",
          "updatedAt": "2024-06-27T15:50:03Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I like the direction this is going. Perhaps we could go with the following, from lines 159 - 163:\r\n\r\nSince Certificate Transparency pairs certificates with SCTs issued from a third party, these timestamps can be used to measure the cutoff date, so the distrusted CA cannot backdate certificates in CT-enforcing clients. Since the existence of SCTs implies the corresponding certificate is present in multiple CT logs, the set of remaining trusted certificates is known and will decrease over time as certificates expire or are replaced. While this strategy is a useful tool, it is not a complete solution:\r\n\r\n* Not all distrusts present fact patterns that lend themselves to SCT-based distrust. For example, if too many certificates were misissued before the cutoff date, revocation lists may become too large to feasibly deliver to clients. Moving cutoff dates earlier risks additional breakage for sites unaffected by misissuance. During PKI transitions, root programs evaluate such tradeoffs, picking the approach that best suits the security needs of their users. \r\n\r\n* There are certain CA failure modes for which trusting certificates before a certain date is inappropriate. For example, a CA that has been performing domain validation incorrectly may have never issued a certificate correctly. Auditing the entire corpus of certificates issued from this CA to determine which were misissued may be infeasible due to both scale and changes in subscribers and domain ownership over time. \r\n\r\n* Clients that do not enforce Certificate Transparency are also still vulnerable to backdating, since such certificates would successfully validate without the SCTs present to indicate the incorrect issuance time asserted in the certificate.\r\n\r\n* Additionally, this strategy does not help server operators address challenge (2). The server must still switch to a replacement CA before the cutoff date, under the same constraints as in a more straightforward distrust. The following section discusses this further.\r\n",
              "createdAt": "2024-06-27T15:49:16Z",
              "updatedAt": "2024-06-27T15:50:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s5_6buv",
          "commit": {
            "abbreviatedOid": "69e40db"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-27T17:19:28Z",
          "updatedAt": "2024-06-27T17:19:28Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Applied",
              "createdAt": "2024-06-27T17:19:28Z",
              "updatedAt": "2024-06-27T17:19:28Z"
            }
          ]
        }
      ]
    },
    {
      "number": 36,
      "id": "PR_kwDOKigz-s5z8DKx",
      "title": "Trust Anchor Identifiers",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/36",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "devonobrien",
        "bob-beck"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2024-06-28T22:55:22Z",
      "updatedAt": "2024-06-28T22:59:44Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "0e117cd3de3e50ea14c1d4e7d1a0e766bf19a5b5",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "trust-anchor-ids",
      "headRefOid": "136ed7e299209500e8e0506a4b11d99fb7526fbe",
      "closedAt": "2024-06-28T22:59:41Z",
      "mergedAt": "2024-06-28T22:59:41Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "90fe2b8b46892a6d33a7657f9437961a4074442c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6AGHVv",
          "commit": {
            "abbreviatedOid": "136ed7e"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-28T22:58:50Z",
          "updatedAt": "2024-06-28T22:58:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 37,
      "id": "PR_kwDOKigz-s5z_mip",
      "title": "Clarify that we omit the tag and length",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/37",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "devonobrien",
        "bob-beck"
      ],
      "labels": [],
      "body": "X.690 unambiguous defines the \"contents octets\", but people probably don't have X.690 memorized, so add an extra sentence to further clarify it. Thanks to Russ Housley for pointing out this was confusing.",
      "createdAt": "2024-06-30T19:34:20Z",
      "updatedAt": "2024-07-02T21:29:15Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "d060854042871eec9f85dc9af92352b09dc37b6b",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "clarify-contents-octets",
      "headRefOid": "40c0e099f302269870e0893272e84ba82d476d11",
      "closedAt": "2024-07-02T21:29:11Z",
      "mergedAt": "2024-07-02T21:29:11Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "fe7adb6f0fe3a23ef26e93a2eb8b6b9874dc52bf"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6AadLi",
          "commit": {
            "abbreviatedOid": "40c0e09"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-02T17:09:12Z",
          "updatedAt": "2024-07-02T17:09:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 38,
      "id": "PR_kwDOKigz-s50OZe4",
      "title": "Update the explainer text to cover both drafts",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/38",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "devonobrien",
        "bob-beck"
      ],
      "labels": [],
      "body": "Since most of this applies equally to both, just switch to discussing \"trust anchor negotiation\" as a general problem space. Generalizing it also lets us talk about the interaction with pinning.",
      "createdAt": "2024-07-02T16:54:32Z",
      "updatedAt": "2024-07-02T17:29:51Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "d060854042871eec9f85dc9af92352b09dc37b6b",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "explainer-both",
      "headRefOid": "5f347fd4a03be8b279e7ecaf952d2572a6220cf8",
      "closedAt": "2024-07-02T17:29:49Z",
      "mergedAt": "2024-07-02T17:29:49Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "6f407031d56ce84177de9ab4b557d2635d71c1e5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6AaYh7",
          "commit": {
            "abbreviatedOid": "30575c0"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-02T17:00:03Z",
          "updatedAt": "2024-07-02T17:02:52Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "handle this case more efficiently",
              "createdAt": "2024-07-02T17:00:04Z",
              "updatedAt": "2024-07-02T17:02:52Z"
            },
            {
              "originalPosition": 58,
              "body": "and perhaps reword \"the TLS Trust Anchor Identifiers option\" as just TLS Trust Anchor Identifiers (to mimic how you use TLS Trust Expressions)",
              "createdAt": "2024-07-02T17:01:32Z",
              "updatedAt": "2024-07-02T17:02:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6AamLr",
          "commit": {
            "abbreviatedOid": "30575c0"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-02T17:27:49Z",
          "updatedAt": "2024-07-02T17:27:49Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Rephrased a bit. Put the TAI option first, which seemed more natural anyway.",
              "createdAt": "2024-07-02T17:27:49Z",
              "updatedAt": "2024-07-02T17:27:49Z"
            }
          ]
        }
      ]
    },
    {
      "number": 39,
      "id": "PR_kwDOKigz-s50P8Pv",
      "title": "Slightly tweak Privacy Considerations",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/39",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "devonobrien",
        "bob-beck"
      ],
      "labels": [],
      "body": "Using a parallel wording between all three cases seems clearer. Also emphasize \"unconditionally\" and \"conditionally\" since we're basically defining terms.\r\n\r\nAlso fix a few places where double spaces snuck in from the Markdown export.",
      "createdAt": "2024-07-02T21:11:59Z",
      "updatedAt": "2024-07-11T14:02:38Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "9c6f0126aa4ba5b19dcbb60eb31cded81708702e",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "privacy-considerations-editorial",
      "headRefOid": "b89507679eeededbdfd1b6288babf2981e6a7a5d",
      "closedAt": "2024-07-11T14:02:34Z",
      "mergedAt": "2024-07-11T14:02:34Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "f7dffcdaa98f77d8aa8a3bb77f0fe9ddca1f745e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6BZ1gZ",
          "commit": {
            "abbreviatedOid": "c975240"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-11T06:35:44Z",
          "updatedAt": "2024-07-11T06:35:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 40,
      "id": "PR_kwDOKigz-s503yN-",
      "title": "There are three trust anchor ID representations, not two",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/40",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "devonobrien",
        "bob-beck"
      ],
      "labels": [],
      "body": "Adding on to https://github.com/davidben/tls-trust-expressions/pull/37, also based on feedback from Russ Housley.\r\n\r\n(Whether we actually want three reprs, I dunno. This is perhaps excessive. We could just decide there are only binary and text reprs and that, if you stick them in an ASN.1 structure, forget their OID heritage and put it in an OCTET STRING. It just changes the tag. But, for now, just describe the thing we got. This is not a particular important bikeshed.)",
      "createdAt": "2024-07-09T18:47:21Z",
      "updatedAt": "2024-07-10T13:01:45Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "fe7adb6f0fe3a23ef26e93a2eb8b6b9874dc52bf",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "trust-anchor-id-reprs",
      "headRefOid": "94b050e0e7161f5971e5de440dd3f8852720ae16",
      "closedAt": "2024-07-10T13:01:42Z",
      "mergedAt": "2024-07-10T13:01:42Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "9c6f0126aa4ba5b19dcbb60eb31cded81708702e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6BOzBb",
          "commit": {
            "abbreviatedOid": "94b050e"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-10T06:27:04Z",
          "updatedAt": "2024-07-10T06:27:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 42,
      "id": "PR_kwDOKigz-s51j7wn",
      "title": "Switch a couple lines in the explainer",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/42",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The ability to transparently provision multiple certificates is less a goal from first principles and more a direct corrollary of minimizing server operator burden.",
      "createdAt": "2024-07-16T21:05:15Z",
      "updatedAt": "2024-07-18T15:39:47Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "f7dffcdaa98f77d8aa8a3bb77f0fe9ddca1f745e",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "explainer-switch-lines",
      "headRefOid": "f1852f26144f3469c4f55451acdc1f3dcb8bb3c7",
      "closedAt": "2024-07-18T15:39:43Z",
      "mergedAt": "2024-07-18T15:39:42Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "74bba0f8a759712aee51a34117057096a29bcfa5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6CTsBz",
          "commit": {
            "abbreviatedOid": "f1852f2"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-18T15:30:29Z",
          "updatedAt": "2024-07-18T15:30:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 43,
      "id": "PR_kwDOKigz-s51rrbT",
      "title": "Add a discussion of targetting attacks to Security Considerations",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/43",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "devonobrien",
        "bob-beck"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2024-07-17T19:08:51Z",
      "updatedAt": "2024-07-17T19:23:52Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "f7dffcdaa98f77d8aa8a3bb77f0fe9ddca1f745e",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "targetting",
      "headRefOid": "334d1291f1a3bab23f30ef29185549bb5414e42f",
      "closedAt": "2024-07-17T19:23:50Z",
      "mergedAt": "2024-07-17T19:23:50Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "7d1e507ed75fa0fa149c62243afdb0df1ec09279"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6CKrf5",
          "commit": {
            "abbreviatedOid": "e583eb7"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-17T19:18:55Z",
          "updatedAt": "2024-07-17T19:18:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 44,
      "id": "PR_kwDOKigz-s51tv2A",
      "title": "Clarify the Serving Multiple Certificates section",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/44",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "devonobrien",
        "bob-beck"
      ],
      "labels": [],
      "body": "Spell out a bit more explicitly that issuing certificates and escrowing private keys are not the same thing.",
      "createdAt": "2024-07-18T02:29:58Z",
      "updatedAt": "2024-07-18T02:31:47Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "221e2c2866c3732c521be7b5b2f3d399b61c6e03",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "issuance-is-not-escrow",
      "headRefOid": "104597b55c6625172b21d64a0ac104a44ae00774",
      "closedAt": "2024-07-18T02:31:43Z",
      "mergedAt": "2024-07-18T02:31:43Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "4b0c7091a3419ba0f485b8f5d9f51497b5027902"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6CNHTs",
          "commit": {
            "abbreviatedOid": "104597b"
          },
          "author": "devonobrien",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-18T02:31:33Z",
          "updatedAt": "2024-07-18T02:31:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 45,
      "id": "PR_kwDOKigz-s51yrya",
      "title": "Clarify that we don't enumerate colocated services",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/45",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "devonobrien",
        "bob-beck"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2024-07-18T14:48:36Z",
      "updatedAt": "2024-07-18T19:56:24Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "4b0c7091a3419ba0f485b8f5d9f51497b5027902",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "hidden-services-are-fine",
      "headRefOid": "e542bb876a7a6eede6390060ef25dad956f825cf",
      "closedAt": "2024-07-18T19:56:21Z",
      "mergedAt": "2024-07-18T19:56:21Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "be4a37e795f0db3476b845114466c0ae1ee8b6d0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6CVwei",
          "commit": {
            "abbreviatedOid": "e542bb8"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-18T19:53:02Z",
          "updatedAt": "2024-07-18T19:53:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 46,
      "id": "PR_kwDOKigz-s510q_l",
      "title": "Clarify who allocates trust anchor IDs",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/46",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "devonobrien",
        "bob-beck"
      ],
      "labels": [],
      "body": "It's pretty clear from the rest of the document that there is no downside to coordinating on these IDs (in fact the CertificatePropertyList extension presumes they are global), but say it explicitly for folks who did not follow this.",
      "createdAt": "2024-07-18T19:50:37Z",
      "updatedAt": "2024-07-18T21:25:18Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "74bba0f8a759712aee51a34117057096a29bcfa5",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "id-allocation",
      "headRefOid": "291f033c69d7d7d2b05a22c0f6930000b0a1f3a5",
      "closedAt": "2024-07-18T19:56:29Z",
      "mergedAt": "2024-07-18T19:56:29Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "a0827b777a96e5e537f7fd2395a5d4f9e11563c0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6CVwHW",
          "commit": {
            "abbreviatedOid": "291f033"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-18T19:51:59Z",
          "updatedAt": "2024-07-18T19:51:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 47,
      "id": "PR_kwDOKigz-s519kgU",
      "title": "Add surveillance-and-trust-anchor-negotiation.md",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/47",
      "state": "MERGED",
      "author": "devonobrien",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-07-20T00:52:42Z",
      "updatedAt": "2024-07-20T00:58:01Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "a0827b777a96e5e537f7fd2395a5d4f9e11563c0",
      "headRepository": "devonobrien/tls-trust-anchor-ids",
      "headRefName": "main",
      "headRefOid": "1bf7683b9831b9ac4da3d5219f1ad2cb80253f8d",
      "closedAt": "2024-07-20T00:58:01Z",
      "mergedAt": "2024-07-20T00:58:01Z",
      "mergedBy": "bob-beck",
      "mergeCommit": {
        "oid": "a1e3b259113c8f9d0334264b8279dead3c8a512e"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 48,
      "id": "PR_kwDOKigz-s519laa",
      "title": "Add link to surveillance analysis to README.md",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/48",
      "state": "MERGED",
      "author": "bob-beck",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-07-20T01:02:49Z",
      "updatedAt": "2024-07-20T01:03:38Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "a1e3b259113c8f9d0334264b8279dead3c8a512e",
      "headRepository": "bob-beck/tls-trust-expressions",
      "headRefName": "main",
      "headRefOid": "f6639d35475b544567a3405ff01c8a19baa2b432",
      "closedAt": "2024-07-20T01:03:38Z",
      "mergedAt": "2024-07-20T01:03:38Z",
      "mergedBy": "devonobrien",
      "mergeCommit": {
        "oid": "a8117bafc5dee0c5ed1482ace89c2f839bf4a7b3"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 49,
      "id": "PR_kwDOKigz-s51-Eze",
      "title": "Don't list the TLS messages twice",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/49",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "devonobrien",
        "bob-beck"
      ],
      "labels": [],
      "body": "We list the TLS messages that carry the extension twice in a row, and the second time we got it wrong. Dedup them.",
      "createdAt": "2024-07-20T04:54:20Z",
      "updatedAt": "2024-07-20T20:23:50Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "24d91689c620e30b6d1f5277232aa2e385c59c7f",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "dedup-msg-list",
      "headRefOid": "1703b26c165587fa01b13c46a92c8e7c95914cd4",
      "closedAt": "2024-07-20T20:22:05Z",
      "mergedAt": "2024-07-20T20:22:05Z",
      "mergedBy": "bob-beck",
      "mergeCommit": {
        "oid": "9fa4aa7956ec56ba0344757dfd45ca4ce607aeda"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 50,
      "id": "PR_kwDOKigz-s52RfPP",
      "title": "Add an actual overview for the two drafts",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/50",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "devonobrien",
        "bob-beck"
      ],
      "labels": [],
      "body": "When I originally wrote this, I was lazy and just referenced the other documents' intros. Write some text inline so the explainer works more standalone.",
      "createdAt": "2024-07-23T23:24:35Z",
      "updatedAt": "2024-07-23T23:39:27Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "9fa4aa7956ec56ba0344757dfd45ca4ce607aeda",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "explainer-overview",
      "headRefOid": "db0b55683d0dec605923228b10bcf58f36755722",
      "closedAt": "2024-07-23T23:38:46Z",
      "mergedAt": "2024-07-23T23:38:46Z",
      "mergedBy": "devonobrien",
      "mergeCommit": {
        "oid": "cb3f9c9072e913e3829902701c1441c317cbed3d"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 52,
      "id": "PR_kwDOKigz-s52fpLe",
      "title": "Bring In CertificatePropertyList from Trust Expressions.",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/52",
      "state": "MERGED",
      "author": "bob-beck",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Bring in CertificatePropertyList from Trust Expressions.\r\n\r\nIssue: 51",
      "createdAt": "2024-07-25T17:15:02Z",
      "updatedAt": "2024-07-25T20:34:16Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "cb3f9c9072e913e3829902701c1441c317cbed3d",
      "headRepository": "bob-beck/tls-trust-expressions",
      "headRefName": "main",
      "headRefOid": "c77e8b00ae1607ddde59c889b837c5cb82643675",
      "closedAt": "2024-07-25T19:53:44Z",
      "mergedAt": "2024-07-25T19:53:44Z",
      "mergedBy": "bob-beck",
      "mergeCommit": {
        "oid": "d7fb9b90ff273ab62ae085e9b7a785b8cb9fddfa"
      },
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Linking to issue #51. (`Issue: 51` doesn't work in GitHub.)",
          "createdAt": "2024-07-25T20:34:15Z",
          "updatedAt": "2024-07-25T20:34:15Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6DJRRP",
          "commit": {
            "abbreviatedOid": "f8c6213"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-25T19:38:32Z",
          "updatedAt": "2024-07-25T19:39:50Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "We end up defining this enum twice, one time with value zero and another time with value TBD. :-) Perhaps we just delete this copy?",
              "createdAt": "2024-07-25T19:38:32Z",
              "updatedAt": "2024-07-25T19:39:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6DJdSE",
          "commit": {
            "abbreviatedOid": "f8c6213"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-25T19:53:17Z",
          "updatedAt": "2024-07-25T19:53:18Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "yeah removed this one and hoisted some of the text up. ",
              "createdAt": "2024-07-25T19:53:17Z",
              "updatedAt": "2024-07-25T19:53:18Z"
            }
          ]
        }
      ]
    },
    {
      "number": 55,
      "id": "PR_kwDOKigz-s52gww4",
      "title": "Bring in Media Type and ACME discussion from Trust Expressions.",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/55",
      "state": "MERGED",
      "author": "bob-beck",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Bring in Media Type and ACME discussion from Trust Expressions.\r\n\r\nIssue: 51",
      "createdAt": "2024-07-25T20:28:04Z",
      "updatedAt": "2024-07-25T20:47:22Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "d7fb9b90ff273ab62ae085e9b7a785b8cb9fddfa",
      "headRepository": "bob-beck/tls-trust-expressions",
      "headRefName": "main",
      "headRefOid": "20cb90a58c58aace2b2770dfbc2ec40702445c36",
      "closedAt": "2024-07-25T20:47:22Z",
      "mergedAt": "2024-07-25T20:47:22Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "67d748f0c839612eb332a50400fe4242ee32bfd9"
      },
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Leaving this comment to link to issue #51. (`Issue: 51` doesn't work in GitHub.)",
          "createdAt": "2024-07-25T20:34:44Z",
          "updatedAt": "2024-07-25T20:34:59Z"
        },
        {
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah I was in the middle of trying to discern the warnings from errors to fix it ;)\r\n",
          "createdAt": "2024-07-25T20:38:32Z",
          "updatedAt": "2024-07-25T20:38:32Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I think you need to replace \"See {{Section 9 of I-D.davidben-tls-trust-expr}}.\" with \"See {{Section 9 of ?I-D.davidben-tls-trust-expr}}\".\r\n\r\n(At least one reference needs to specify `!` for normative or `?` for informative. We've dropped the last normative use, so I guess it's just informative now.)",
          "createdAt": "2024-07-25T20:38:33Z",
          "updatedAt": "2024-07-25T20:38:33Z"
        },
        {
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "body": "fun.. of course I'm just about to remove that in the next pr.. :) \r\n",
          "createdAt": "2024-07-25T20:40:21Z",
          "updatedAt": "2024-07-25T20:40:21Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6DJ87j",
          "commit": {
            "abbreviatedOid": "e202972"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-25T20:36:28Z",
          "updatedAt": "2024-07-25T20:36:28Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKigz-s6DJ9NI",
          "commit": {
            "abbreviatedOid": "c229df3"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Oh actually this doesn't build...\r\nhttps://github.com/davidben/tls-trust-expressions/actions/runs/10101106704/job/27933936650?pr=55",
          "createdAt": "2024-07-25T20:37:11Z",
          "updatedAt": "2024-07-25T20:37:11Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKigz-s6DKA9G",
          "commit": {
            "abbreviatedOid": "20cb90a"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-25T20:47:11Z",
          "updatedAt": "2024-07-25T20:47:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 56,
      "id": "PR_kwDOKigz-s52g3js",
      "title": "Fix up the first paragraph of CertificatePropertyList",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/56",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "devonobrien",
        "bob-beck"
      ],
      "labels": [],
      "body": "The intro made sense for trust expressions, but trust anchor IDs has no reference to trust stores.\r\n\r\nIssue #51.",
      "createdAt": "2024-07-25T20:51:26Z",
      "updatedAt": "2024-07-25T21:12:54Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "67d748f0c839612eb332a50400fe4242ee32bfd9",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "cert-props-fixup",
      "headRefOid": "72c2635271f987b7bdd58e42b14f8e0635d5b125",
      "closedAt": "2024-07-25T20:57:59Z",
      "mergedAt": "2024-07-25T20:57:59Z",
      "mergedBy": "bob-beck",
      "mergeCommit": {
        "oid": "67e6ab52d5b738ec1fdccc799941230041714873"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6DKEsx",
          "commit": {
            "abbreviatedOid": "72c2635"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-25T20:57:47Z",
          "updatedAt": "2024-07-25T20:57:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 57,
      "id": "PR_kwDOKigz-s52g57q",
      "title": "Bring in use cases from Trust Expressions.",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/57",
      "state": "MERGED",
      "author": "bob-beck",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Bring in use cases from Trust Expressions.",
      "createdAt": "2024-07-25T20:59:55Z",
      "updatedAt": "2024-07-25T21:14:05Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "67e6ab52d5b738ec1fdccc799941230041714873",
      "headRepository": "bob-beck/tls-trust-expressions",
      "headRefName": "main",
      "headRefOid": "3724b8be7ae3c6c8d5d664b7053494b3fc2464e5",
      "closedAt": "2024-07-25T21:14:05Z",
      "mergedAt": "2024-07-25T21:14:05Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "92b3ee34e60c62b23b8b66851920a6cddebf86d5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6DKKIE",
          "commit": {
            "abbreviatedOid": "3724b8b"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-25T21:13:57Z",
          "updatedAt": "2024-07-25T21:13:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 58,
      "id": "PR_kwDOKigz-s52hBq1",
      "title": "Add a discussion of pinning to trust anchor IDs",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/58",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "devonobrien",
        "bob-beck"
      ],
      "labels": [],
      "body": "Trust expressions weren't as good at this, but trust anchor IDs can handle it just fine.",
      "createdAt": "2024-07-25T21:29:53Z",
      "updatedAt": "2024-07-25T23:41:59Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "3f31f212208d37becd7067f0cf5e83862c95f181",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "pinning",
      "headRefOid": "59702ed6f0bd3e7f07e5a107c1346e0f8693c47b",
      "closedAt": "2024-07-25T23:41:53Z",
      "mergedAt": "2024-07-25T23:41:53Z",
      "mergedBy": "bob-beck",
      "mergeCommit": {
        "oid": "0183c5e96bf935509630d1d761eade5bb0bdc7c0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6DKja_",
          "commit": {
            "abbreviatedOid": "59702ed"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-25T22:50:17Z",
          "updatedAt": "2024-07-25T22:50:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 59,
      "id": "PR_kwDOKigz-s52hP8u",
      "title": "fix build",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/59",
      "state": "MERGED",
      "author": "bob-beck",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-07-25T22:27:17Z",
      "updatedAt": "2024-07-25T22:38:51Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "92b3ee34e60c62b23b8b66851920a6cddebf86d5",
      "headRepository": "bob-beck/tls-trust-expressions",
      "headRefName": "main",
      "headRefOid": "c235ddf2b31fcfdba82240922e8eeed1a0f95c76",
      "closedAt": "2024-07-25T22:38:51Z",
      "mergedAt": "2024-07-25T22:38:50Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "3f31f212208d37becd7067f0cf5e83862c95f181"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6DKfsj",
          "commit": {
            "abbreviatedOid": "156cc2e"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-25T22:31:39Z",
          "updatedAt": "2024-07-25T22:38:03Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Nit: You only need this if you're changing from the default label. (Default label is lowercase with hyphens.)\r\n\r\n",
              "createdAt": "2024-07-25T22:31:39Z",
              "updatedAt": "2024-07-25T22:38:03Z"
            },
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n## Certificate Selection\r\n```",
              "createdAt": "2024-07-25T22:33:22Z",
              "updatedAt": "2024-07-25T22:38:04Z"
            },
            {
              "originalPosition": 14,
              "body": "Super nitpicky nitpick: it's really the whole protocol, not just the selection algorithm, since sometimes we effectively invert selection. TBH since it's clearly in the context of this (much shorter) document, I think we can just write...\r\n\r\n```suggestion\r\nA CA operator could provide subscribers with two certification paths: a longer path ending at a long-lived trust anchor and shorter path the other ending at a short-lived, revocable root. Relying parties would be configured to trust both the long-lived root and the most recent short-lived root. A server that prioritizes the shorter path would then send the shorter path to up-to-date relying parties and the longer path to older relying parties.\r\n```",
              "createdAt": "2024-07-25T22:37:58Z",
              "updatedAt": "2024-07-25T22:38:04Z"
            }
          ]
        }
      ]
    },
    {
      "number": 60,
      "id": "PR_kwDOKigz-s52hXiu",
      "title": "Clarify todo",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/60",
      "state": "MERGED",
      "author": "bob-beck",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Clarify todo",
      "createdAt": "2024-07-25T23:10:46Z",
      "updatedAt": "2024-07-25T23:39:12Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "3f31f212208d37becd7067f0cf5e83862c95f181",
      "headRepository": "bob-beck/tls-trust-expressions",
      "headRefName": "main",
      "headRefOid": "f9b7ddd392f13ab51d65663d8b1efd4eccb8a902",
      "closedAt": "2024-07-25T23:39:12Z",
      "mergedAt": "2024-07-25T23:39:12Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "9105535e46743ea35aa2da2c6423484ea8985336"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6DKsP0",
          "commit": {
            "abbreviatedOid": "f9b7ddd"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-25T23:39:05Z",
          "updatedAt": "2024-07-25T23:39:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 61,
      "id": "PR_kwDOKigz-s52hZZW",
      "title": "Update TODO with CertificatePropertyList move",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/61",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "devonobrien",
        "bob-beck"
      ],
      "labels": [],
      "body": "Issue #51",
      "createdAt": "2024-07-25T23:22:39Z",
      "updatedAt": "2025-02-25T15:36:32Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "3f31f212208d37becd7067f0cf5e83862c95f181",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "update-todo",
      "headRefOid": "e91b913dc6bac844e66e24178b74d0340cef3808",
      "closedAt": "2024-07-25T23:42:54Z",
      "mergedAt": "2024-07-25T23:42:54Z",
      "mergedBy": "bob-beck",
      "mergeCommit": {
        "oid": "5e978b6070b08968b6bffc6894e25f15689adbc6"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 66,
      "id": "PR_kwDOKigz-s54C0MQ",
      "title": "Cap trust anchor IDs to 255 bytes",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/66",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "devonobrien",
        "bob-beck"
      ],
      "labels": [],
      "body": "So that the 1-byte length prefix works. Fixes #65. 255 bytes should be far more than enough; if you're anywhere near that, you could have just used a SHA-256 hash of something.\r\n\r\n(Admittedly, the OID idea does not lend itself well to SHA-256 hashes. You can encode them but it's a little fussy. Probably the most straightforward is to use 37 7-bit components.)",
      "createdAt": "2024-08-11T23:50:27Z",
      "updatedAt": "2024-08-12T17:16:11Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "ca27e6fb20f1baf6850c9b092a794784a79cefc5",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "id-length-limit",
      "headRefOid": "cc11aa19de407c97cc69d58c51123320ec030cda",
      "closedAt": "2024-08-12T17:16:08Z",
      "mergedAt": "2024-08-12T17:16:08Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "8d62b492566d8f1af6bcd56e24d170aa899b2106"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6FC0ox",
          "commit": {
            "abbreviatedOid": "cc11aa1"
          },
          "author": "bwesterb",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-12T06:12:21Z",
          "updatedAt": "2024-08-12T06:12:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 67,
      "id": "PR_kwDOKigz-s54Z0dF",
      "title": "Link the explainer first",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/67",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "devonobrien",
        "bob-beck"
      ],
      "labels": [],
      "body": "That's probably a better place to start.",
      "createdAt": "2024-08-14T20:07:24Z",
      "updatedAt": "2024-08-14T20:33:48Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "8d62b492566d8f1af6bcd56e24d170aa899b2106",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "reorder-readme",
      "headRefOid": "0a1b64f6c1230845aa6a4e5d2591c8715eac08dd",
      "closedAt": "2024-08-14T20:33:46Z",
      "mergedAt": "2024-08-14T20:33:46Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "38cedfedc3694f63ed2cfa932a0f8db8722eee58"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6FdgjM",
          "commit": {
            "abbreviatedOid": "0a1b64f"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-14T20:13:53Z",
          "updatedAt": "2024-08-14T20:13:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 68,
      "id": "PR_kwDOKigz-s54akcg",
      "title": "Small cleanups I forgot to pr",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/68",
      "state": "CLOSED",
      "author": "bob-beck",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-08-14T22:54:13Z",
      "updatedAt": "2024-08-30T18:54:38Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "08f55bff1c15b4877d614859d6b8ab0ac6ec6975",
      "headRepository": "bob-beck/tls-trust-expressions",
      "headRefName": "main",
      "headRefOid": "acea2077167a0600a8fa1f870d83e29a8502e59c",
      "closedAt": "2024-08-30T18:54:38Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "For some reason GitHub is telling me the diff is empty. Did the merge commit clobber things somehow?",
          "createdAt": "2024-08-15T00:56:48Z",
          "updatedAt": "2024-08-15T00:56:48Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 69,
      "id": "PR_kwDOKigz-s54x8ND",
      "title": "Editorial changes to security considerations",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/69",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "devonobrien",
        "bob-beck"
      ],
      "labels": [],
      "body": "This says the same thing, but tries to be bit clearer in spelling out standard properties of all PKI-based schemes.",
      "createdAt": "2024-08-19T20:49:10Z",
      "updatedAt": "2024-08-19T21:04:20Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "38cedfedc3694f63ed2cfa932a0f8db8722eee58",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "sec-considerations",
      "headRefOid": "05e7e267100bb458b44007ad5940493ca0abcb17",
      "closedAt": "2024-08-19T21:04:17Z",
      "mergedAt": "2024-08-19T21:04:17Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "08f55bff1c15b4877d614859d6b8ab0ac6ec6975"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6F5eYL",
          "commit": {
            "abbreviatedOid": "7adbaba"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-19T20:51:06Z",
          "updatedAt": "2024-08-19T20:57:12Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I might just say \"name\" instead of \"DNS name, etc.\"",
              "createdAt": "2024-08-19T20:51:06Z",
              "updatedAt": "2024-08-19T20:57:12Z"
            },
            {
              "originalPosition": 8,
              "body": "( or do something to get rid of the etc.)",
              "createdAt": "2024-08-19T20:54:42Z",
              "updatedAt": "2024-08-19T20:57:12Z"
            },
            {
              "originalPosition": 8,
              "body": "Same as above.",
              "createdAt": "2024-08-19T20:56:26Z",
              "updatedAt": "2024-08-19T20:57:12Z"
            }
          ]
        }
      ]
    },
    {
      "number": 70,
      "id": "PR_kwDOKigz-s56A44y",
      "title": "This language needs changing from Trust Expressions",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/70",
      "state": "MERGED",
      "author": "bob-beck",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fix up some of this language which doesn't work for Trust Anchor Identifiers. ",
      "createdAt": "2024-08-30T18:55:13Z",
      "updatedAt": "2024-08-30T20:49:46Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "08f55bff1c15b4877d614859d6b8ab0ac6ec6975",
      "headRepository": "bob-beck/tls-trust-expressions",
      "headRefName": "main",
      "headRefOid": "ada36df45a3f1ddb1e328e9164e26f10f9bf3372",
      "closedAt": "2024-08-30T20:49:46Z",
      "mergedAt": "2024-08-30T20:49:46Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "0188581b8cc5e1a19993aeec800af1d5801512eb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6HgONC",
          "commit": {
            "abbreviatedOid": "acea207"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-30T19:35:53Z",
          "updatedAt": "2024-08-30T19:36:13Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "Ah, good catch. Some overall comments:\r\n\r\nFor brevity, I think we can take it as read that if you generate a new root CA, you generate a new ID if you're participating in this mechanism.\r\n\r\nWe've actually never defined the client to having a preference between trust anchors. The client *can*, but it's a little goofy because only the server knows the sizes of the proofs and the performance of the corresponding keys, which is why we have a server preference list. Also, at the end of the day, the client doesn't care as long as it got a proof from _something_ it trusts.\r\n\r\nThe other complexity is that this draft covers both `certificate_authorities`-style selection and the client-selection one. But I think we can say what we're trying to say more succinctly and more generally.\r\n\r\nHow about this?\r\n\r\n1. The CA operator generates a new root CA with a separate key, but continues operating the old root CA.\r\n2. Root programs being trusting the new root CA alongside the old one, as a transition state. Both root CAs are configured to participate in trust anchor negotiation.\r\n3. When subscribers request certificates, the CA operator issues certificates from both roots and provisions the subscriber with both certificates.\r\n4. Trust anchor negotiation selects the old root for relying parties that only trust the old root, and the new root for relying parties that only trust the new root. In transition, relying parties that trust both may be served either, but prioritizing the new root helps monitor the transition.\r\n5. Once subscribers have been provisioned with new certificates, root programs can safely distrust the old root in new relying parties. The CA operator may continue to operate the old root CA for as long as it wishes to serve subscribers that, in turn, wish to serve older relying parties.",
              "createdAt": "2024-08-30T19:35:53Z",
              "updatedAt": "2024-08-30T19:47:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6HgoFm",
          "commit": {
            "abbreviatedOid": "acea207"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-30T20:44:32Z",
          "updatedAt": "2024-08-30T20:44:32Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "Yeah, the generic language works just fine here.  Took it. ",
              "createdAt": "2024-08-30T20:44:32Z",
              "updatedAt": "2024-08-30T20:44:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6HgpNs",
          "commit": {
            "abbreviatedOid": "34bda5f"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-30T20:49:00Z",
          "updatedAt": "2024-08-30T20:49:15Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n2. Root programs begin trusting the new root CA alongside the old one, as a transition state. Both root CAs are configured to participate in trust anchor negotiation.\r\n```\r\n\r\nMy fault. I introduced a typo.",
              "createdAt": "2024-08-30T20:49:00Z",
              "updatedAt": "2024-08-30T20:49:15Z"
            }
          ]
        }
      ]
    },
    {
      "number": 71,
      "id": "PR_kwDOKigz-s56kQXf",
      "title": "Tighten up the introductory text a bit",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/71",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "devonobrien",
        "bob-beck"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2024-09-05T19:17:05Z",
      "updatedAt": "2024-09-05T23:22:16Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "0188581b8cc5e1a19993aeec800af1d5801512eb",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "intro",
      "headRefOid": "6a805cd6eaf358ea39bdc3b879f9d6818fc5d2da",
      "closedAt": "2024-09-05T23:12:43Z",
      "mergedAt": "2024-09-05T23:12:43Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "4f2242a410730602db7e208ccc48c25eb9f9aae3"
      },
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Revised a bit. It's getting late so I'll go ahead and merge this after a once over so we can cut new drafts. (And if I messed something up horribly we can just cut more tomorrow. :) )",
          "createdAt": "2024-09-05T22:58:30Z",
          "updatedAt": "2024-09-05T22:58:30Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6IIcTX",
          "commit": {
            "abbreviatedOid": "c88ebb8"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-05T19:25:16Z",
          "updatedAt": "2024-09-05T19:32:06Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I'm not sure we want to address it here, but there is another challenge with the existing certificate authorities extension. \r\n\r\nCurrently, with path building and cross signs potentially in the mix with the CA extension if a client asks for CA \"Fred\" and a server is in possession of a cross signed gordian knot that could be signed by \"Fred\" \"George\" \"Eugene\" and \"Festus\", The server now must implement path building, find out if their bundle satisfies CA \"Fred\", and if it does then either make the choice to serve up the path built result, or send the original bundle and trust in prayer and clean living that the client will path build and find \"Fred\" rather than something else due to inconsistencies and errors in path building implementations. \r\n\r\nDo we want to mention this here or sweep it under the rug for the moment? \r\n",
              "createdAt": "2024-09-05T19:25:17Z",
              "updatedAt": "2024-09-05T19:32:06Z"
            },
            {
              "originalPosition": 11,
              "body": "(also fine addressing this separately from this re-word)",
              "createdAt": "2024-09-05T19:26:09Z",
              "updatedAt": "2024-09-05T19:32:06Z"
            },
            {
              "originalPosition": 30,
              "body": "Before a new key can be used by a subscriber, all relying parties must trust it. This prevents new keys from being used if a subscriber must support older un-updatable relying parties, or before all relying parties agree to trust the key.  This obstacle to using new keys prevents new CA's from entering the ecosystem, or existing CA's from rotating or deploying new keys. ",
              "createdAt": "2024-09-05T19:31:07Z",
              "updatedAt": "2024-09-05T19:32:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6IIrG5",
          "commit": {
            "abbreviatedOid": "c88ebb8"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-05T20:02:17Z",
          "updatedAt": "2024-09-05T20:02:18Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Also s/smaller PKIs\" \"Trusting fewer CAs\" - to match the follow on text about transitioning to newer CA's. ",
              "createdAt": "2024-09-05T20:02:18Z",
              "updatedAt": "2024-09-05T20:02:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6IItLO",
          "commit": {
            "abbreviatedOid": "c88ebb8"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2024-09-05T20:07:30Z",
          "updatedAt": "2024-09-05T20:07:46Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "They don't define an ACME extension. The use an existing one. \r\n\r\nThe proposals also define a new media type for certificate paths with identifying information, and how this can be used in conjunction with ACME<blah blah> to help subscribers provision and use multiple certificates. ",
              "createdAt": "2024-09-05T20:07:30Z",
              "updatedAt": "2024-09-05T20:07:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6IJMhS",
          "commit": {
            "abbreviatedOid": "c88ebb8"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-05T21:31:29Z",
          "updatedAt": "2024-09-05T21:31:29Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I don't think path-building should be mentioned. It's unrelated to the extension. It's purely how you decided to represent your server configuration. Yes, OpenSSL servers sometimes path-build to compute their own configuration, and we're envisioning that, with the ACME mechanism, servers would not do this. But this has nothing to do with the negotiation scheme:\r\n\r\n* A server that uses `certificate_authorities` could well be configured with pre-built paths and only check the last certificate against the extension.\r\n\r\n* Conversely, a server that uses `trust_anchors` could well take a bag of certificates and path-build on the fly to expand that out into a bunch of candidate paths to send.\r\n\r\nPath-building discussions are mostly a distraction here.",
              "createdAt": "2024-09-05T21:31:29Z",
              "updatedAt": "2024-09-05T21:33:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6IJM5F",
          "commit": {
            "abbreviatedOid": "c88ebb8"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-05T21:32:40Z",
          "updatedAt": "2024-09-05T21:32:40Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Defining a new media type is defining an extension. We are extending ACME. ACME doesn't have a concrete notion of extensions the way that TLS does.",
              "createdAt": "2024-09-05T21:32:40Z",
              "updatedAt": "2024-09-05T21:32:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6IJNAO",
          "commit": {
            "abbreviatedOid": "c88ebb8"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-05T21:33:03Z",
          "updatedAt": "2024-09-05T21:33:03Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Also \"ACME extension\" comes from the existing text. :P",
              "createdAt": "2024-09-05T21:33:03Z",
              "updatedAt": "2024-09-05T21:33:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6IJO3-",
          "commit": {
            "abbreviatedOid": "c88ebb8"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-05T21:37:38Z",
          "updatedAt": "2024-09-05T21:37:38Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "I think \"new CA\" is correct, not \"new key\". \"New key\" reads like it's specifically talking about key rotation, but this is a summary of the general \"new CA\" problem. (CA != CA operator.) But yeah this (existing) line is a little bit hard to read. I'll take a pass and incorporate bits of your text.",
              "createdAt": "2024-09-05T21:37:38Z",
              "updatedAt": "2024-09-05T21:37:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6IJzrD",
          "commit": {
            "abbreviatedOid": "2b25486"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-09-05T23:04:46Z",
          "updatedAt": "2024-09-05T23:04:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 72,
      "id": "PR_kwDOKigz-s56l1Md",
      "title": "Expand on the certificate_authorities discussion in the explainer",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/72",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "devonobrien",
        "bob-beck"
      ],
      "labels": [],
      "body": "The explainer currently says the old one is impractical, which is not true without qualifications. It's perfectly practical for a large class of applications. We're just interested in the cases where it is not.\r\n\r\nAlso, for the many folks who already use certificate_authorities (client certs), it's worth emphasizing that all these extensions coexist just fine.",
      "createdAt": "2024-09-05T23:22:26Z",
      "updatedAt": "2025-02-25T15:36:53Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "4f2242a410730602db7e208ccc48c25eb9f9aae3",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "cert-authorities-discussion",
      "headRefOid": "b693c1894db84860e1b58d6c59adb7cf565ae56f",
      "closedAt": "2024-12-13T00:25:40Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I forgot about this, but I think we can just close this.",
          "createdAt": "2024-12-13T00:25:40Z",
          "updatedAt": "2024-12-13T00:25:40Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6IjrK_",
          "commit": {
            "abbreviatedOid": "b693c18"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-09-09T22:22:48Z",
          "updatedAt": "2024-09-09T22:22:55Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "missing an \"is practical\" and spell \"with\" with an i. ",
              "createdAt": "2024-09-09T22:22:48Z",
              "updatedAt": "2024-09-09T22:22:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 73,
      "id": "PR_kwDOKigz-s56697d",
      "title": "Reorganize the explainer a bit",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/73",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "devonobrien",
        "bob-beck"
      ],
      "labels": [],
      "body": "We ended up with a lot of redundant, somewhat meandering text. I tried to take a pass to clean it up a bit. I left Key Scenarios and Considered Alternatives alone. Those could probably also take a pass, but I think the rest reads a lot better now.",
      "createdAt": "2024-09-10T02:40:30Z",
      "updatedAt": "2024-09-10T21:56:17Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "4f2242a410730602db7e208ccc48c25eb9f9aae3",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "reorg-explainer",
      "headRefOid": "7d0c4bc815a4f6d99acbef33606202d442919f8e",
      "closedAt": "2024-09-10T21:56:14Z",
      "mergedAt": "2024-09-10T21:56:14Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "274116ce1082463992b04fcc3a85579f01ca315e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6IrG_y",
          "commit": {
            "abbreviatedOid": "376f574"
          },
          "author": "devonobrien",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-10T16:16:05Z",
          "updatedAt": "2024-09-10T16:16:05Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "This sort of reads like a requisite lead-in paragraph was deleted, and if you squint, this still reads like the goal of a solution more than a problem statement. I think the conflict between availability and security might better be described as a corollary of the below problem statement, but I'm open to iterating over this if it's headed in the right direction.\r\n\r\n==========\r\nBackground:\r\nToday, TLS subscribers are provisioned with one or more certification paths which they use to authenticate themselves to TLS relying parties. Currently, TLS subscribers lack a reliable way of knowing which among these provisioned paths will be accepted by a given relying party, if any. Absent a clear signal, TLS subscribers are forced to guess, which causes connection failures when this guess is incorrect.\r\n\r\nIn the scenario in which a TLS subscriber wishes to authenticate itself to relying parties with distinct or mutually-exclusive trust settings, there is no single correct answer. Advanced TLS implementations may attempt to use TLS fingerprinting to make informed guesses; however, this is unreliable and client trust may change over time, causing existing fingerprinting mechanisms and the subsequent certification path selection to fail. \r\n\r\nProblem:\r\nTrust Anchor IDs and Trust Expressions present two different approaches to solve the same problem: eliminating the uncertainty around what relying parties trust so that TLS subscribers can obtain, and intelligently serve, a trusted certification path to TLS relying parties.\r\n",
              "createdAt": "2024-09-10T16:16:05Z",
              "updatedAt": "2024-09-10T16:19:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6Iq1nE",
          "commit": {
            "abbreviatedOid": "376f574"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-09-10T15:49:08Z",
          "updatedAt": "2024-09-10T16:17:26Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "policies here sounds a bit too fluffy and vague for the problem statement - can we stick to divers sets of trust anchors or something like that (Trust anchors can be referenced straight out of 5280 I believe)",
              "createdAt": "2024-09-10T15:50:05Z",
              "updatedAt": "2024-09-10T16:17:26Z"
            },
            {
              "originalPosition": 29,
              "body": "I really think the use of \"CA\" interchanably with \"key\" hurts us in this section.. I know it is sort of the \"standard\" in these documents and I hate it. ",
              "createdAt": "2024-09-10T15:58:43Z",
              "updatedAt": "2024-09-10T16:17:26Z"
            },
            {
              "originalPosition": 81,
              "body": "```suggestion\r\n3. To accommodate stale or missing DNS records, servers also send available trust anchors in the TLS handshake. If the client rejects the certificate, it can use this to retry with a more accurate `trust_anchors` request.\r\n```",
              "createdAt": "2024-09-10T16:04:33Z",
              "updatedAt": "2024-09-10T16:17:26Z"
            },
            {
              "originalPosition": 104,
              "body": "```suggestion\r\nBoth drafts anticipate a model where servers automatically provision a collection of candidate certificate paths, with some associated selection metadata, instead of a single path. When a client connect, the server software automatically selects one to send by matching the ClientHello message against the selection metadata, along with other TLS criteria such as ECDSA vs RSA. If there are multiple matches, server software chooses based on its own criteria, such as certificate size.\r\n```",
              "createdAt": "2024-09-10T16:06:02Z",
              "updatedAt": "2024-09-10T16:17:26Z"
            },
            {
              "originalPosition": 107,
              "body": "```suggestion\r\nIf the negotiation mechanism is either not supported or did not match a candidate, servers should behave as they do today, possibly falling back to a single default certificate or heuristics. However, each client that deploys negotiation no longer constrains that fallback path, increasing the choices available for a valid fallback certificate for the remaining clients.\r\n```",
              "createdAt": "2024-09-10T16:10:53Z",
              "updatedAt": "2024-09-10T16:17:26Z"
            },
            {
              "originalPosition": 149,
              "body": "```suggestion\r\nIn other transitions, reducing delays is also valuable. If trustworthy CA is considered to provide net value to the users of a client and is added, a timely transition allows servers to make use of the CA and provide the benefit of using it to the client.\r\n```",
              "createdAt": "2024-09-10T16:13:30Z",
              "updatedAt": "2024-09-10T16:17:26Z"
            },
            {
              "originalPosition": 156,
              "body": "What risks? (this is the question that will be asked, do we leave it unanswered here?)",
              "createdAt": "2024-09-10T16:14:36Z",
              "updatedAt": "2024-09-10T16:17:26Z"
            },
            {
              "originalPosition": 180,
              "body": "```suggestion\r\nThe two drafts reduce the bandwidth costs of the `certificate_authorities` extension. For PKIs where `certificate_authorities` was already viable, this is a size optimization over the existing deployment model. For PKIs where `certificate_authorities` was prohibitively large, this provides negotiaiton with minimal size cost.\r\n```",
              "createdAt": "2024-09-10T16:15:57Z",
              "updatedAt": "2024-09-10T16:17:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6IrJob",
          "commit": {
            "abbreviatedOid": "376f574"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-10T16:20:54Z",
          "updatedAt": "2024-09-10T16:20:54Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I generally like this, other than some degree of discomfort between \"today subscribers are provisioned witth one or more\" - I think we risk the reader believing today it isn't the case and most of the time it's only one.. yeah I know you say one or more, but I think a lot of our readership is stuck in a mode of \"who cares what we have today works fine\"",
              "createdAt": "2024-09-10T16:20:54Z",
              "updatedAt": "2024-09-10T16:20:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6IrPL2",
          "commit": {
            "abbreviatedOid": "376f574"
          },
          "author": "devonobrien",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-10T16:30:40Z",
          "updatedAt": "2024-09-10T16:30:40Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "\"1 or more\" is necessary for the fingerprinting --> cert selection to make sense. Perhaps we can more clearly emphasize that guesses and resulting breakage do happen, if that assuages your concerns about people thinking this doesn't actually happen today (which it does).",
              "createdAt": "2024-09-10T16:30:40Z",
              "updatedAt": "2024-09-10T16:30:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6IrQis",
          "commit": {
            "abbreviatedOid": "376f574"
          },
          "author": "devonobrien",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-10T16:33:12Z",
          "updatedAt": "2024-09-10T16:33:12Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Suggest: \"extend the pattern/mechanism used by the existing TLS 1.3 `certificate_authorities` extension\"",
              "createdAt": "2024-09-10T16:33:12Z",
              "updatedAt": "2024-09-10T16:33:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6Ir2Cw",
          "commit": {
            "abbreviatedOid": "376f574"
          },
          "author": "devonobrien",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-10T17:18:16Z",
          "updatedAt": "2024-09-10T17:18:17Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "nit: including 'extension' in the link after the codeblock formatting causes a weird break that makes it look like it's two separate links. Maybe just linkify `certificate_authorities`",
              "createdAt": "2024-09-10T17:18:17Z",
              "updatedAt": "2024-09-10T17:18:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6Ir2TD",
          "commit": {
            "abbreviatedOid": "376f574"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-10T17:18:36Z",
          "updatedAt": "2024-09-10T17:18:36Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "I don't think the provisioning is necessarily automatic. E.g. your backup certificate idea. Automation is very valuable, but that's covered in the next section.",
              "createdAt": "2024-09-10T17:18:36Z",
              "updatedAt": "2024-09-10T17:18:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6Ir4PA",
          "commit": {
            "abbreviatedOid": "376f574"
          },
          "author": "devonobrien",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-10T17:22:44Z",
          "updatedAt": "2024-09-10T17:22:44Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "We can avoid people rabbit-holing on pinning by saying something more generally true, such as:\r\n\r\n\"Some more specialized clients, such as mobile apps, may be constrained to trusting one or two specific CAs\"",
              "createdAt": "2024-09-10T17:22:44Z",
              "updatedAt": "2024-09-10T17:22:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6Ir8X0",
          "commit": {
            "abbreviatedOid": "376f574"
          },
          "author": "devonobrien",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-10T17:30:02Z",
          "updatedAt": "2024-09-10T17:30:02Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Suggest something like: \"Without a negotiation mechanism, changes to client trust to improve user security directly conflict with service availability, with user security being deprioritized in favor of avoiding any kind of breakage\"\r\n\r\nIMO, framing user security as the cause of client diversity makes this point more clearly.",
              "createdAt": "2024-09-10T17:30:02Z",
              "updatedAt": "2024-09-10T17:30:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6Ir9zJ",
          "commit": {
            "abbreviatedOid": "376f574"
          },
          "author": "devonobrien",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-10T17:33:07Z",
          "updatedAt": "2024-09-10T17:33:07Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "nit: make sure we're consistent about \"certification paths\" vs. \"certificate paths\"",
              "createdAt": "2024-09-10T17:33:07Z",
              "updatedAt": "2024-09-10T17:33:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6Ir-zT",
          "commit": {
            "abbreviatedOid": "376f574"
          },
          "author": "devonobrien",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-10T17:35:15Z",
          "updatedAt": "2024-09-10T17:35:15Z",
          "comments": [
            {
              "originalPosition": 156,
              "body": "It feels like we can TODO a link to separate text that explains this later.",
              "createdAt": "2024-09-10T17:35:15Z",
              "updatedAt": "2024-09-10T17:35:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6Ir5YU",
          "commit": {
            "abbreviatedOid": "fbe1d9d"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-10T17:25:03Z",
          "updatedAt": "2024-09-10T18:39:17Z",
          "comments": [
            {
              "originalPosition": 180,
              "body": "Applied but with spelling fix.",
              "createdAt": "2024-09-10T17:25:03Z",
              "updatedAt": "2024-09-10T18:39:17Z"
            },
            {
              "originalPosition": 149,
              "body": "\"net value to the ecosystem\" is the phrasing we used before. I think that is a better phrasing than to a client.\r\n\r\nThere are many reasons to add CAs. A CA might provide better automation, which directly benefits the server operator. Of course, it indirectly benefits the user by making the system more robust, which is ultimately what this is for. But this is a complicated and broad, so \"ecosystem\" is more appropriate.\r\n\r\nI rephrased a bit so we don't talk about the server benefiting because that's also poor phrasing for the same reason. Also added a couple examples.",
              "createdAt": "2024-09-10T17:37:15Z",
              "updatedAt": "2024-09-10T18:39:17Z"
            },
            {
              "originalPosition": 81,
              "body": "Missing is weird because if it's missing the server should just deploy them. But I do like the tighter phrasing. I did \"stale or unavailable\".",
              "createdAt": "2024-09-10T17:41:35Z",
              "updatedAt": "2024-09-10T18:39:17Z"
            },
            {
              "originalPosition": 156,
              "body": "I mean, the separate text *already exists*. It's Considered Alternatives. I rewrote it slightly and linked there.",
              "createdAt": "2024-09-10T17:42:35Z",
              "updatedAt": "2024-09-10T18:39:17Z"
            },
            {
              "originalPosition": 104,
              "body": "For better or worse, this document uses \"certificate paths\" everywhere. I don't care either way which one we use but matched for now. It's all kind of a mess. Colloquial terminology is overwhelming \"certificate path\" and \"certificate authority\". 5280 says \"certification path\" and \"certification authority\". 8446 says \"certification path\" but \"certificate authority\".",
              "createdAt": "2024-09-10T17:44:35Z",
              "updatedAt": "2024-09-10T18:39:17Z"
            },
            {
              "originalPosition": 53,
              "body": "Applied.",
              "createdAt": "2024-09-10T17:45:03Z",
              "updatedAt": "2024-09-10T18:39:17Z"
            },
            {
              "originalPosition": 44,
              "body": "Applied.",
              "createdAt": "2024-09-10T17:45:30Z",
              "updatedAt": "2024-09-10T18:39:17Z"
            },
            {
              "originalPosition": 29,
              "body": "We're not using it interchangeably.\r\n\r\nA CA is a kind of service that, among other things, uses a key. That service is defined by far more than a key. There's a name and other properties, usually packaged in a self-signed certificate. There's also the software and processes that access and use that key.\r\n\r\nA CA operator is an entity who operates one or more CAs.\r\n\r\nThe client contains a list of CAs, not CA operators. Rarely but sometimes CAs change hands between CA operators, though that is quite a process. When clients make trust decisions, they certainly take CA operators into account, but the trust anchor list is ultimately a list of CAs.\r\n\r\nWe've been pretty consistent throughout all our documents here. I think this is correct. Saying \"key\" loses all the other stuff that is part of a CA.",
              "createdAt": "2024-09-10T17:48:27Z",
              "updatedAt": "2024-09-10T18:39:17Z"
            },
            {
              "originalPosition": 19,
              "body": "Done.",
              "createdAt": "2024-09-10T18:12:57Z",
              "updatedAt": "2024-09-10T18:39:17Z"
            },
            {
              "originalPosition": 19,
              "body": "Done.",
              "createdAt": "2024-09-10T18:38:06Z",
              "updatedAt": "2024-09-10T18:39:17Z"
            },
            {
              "originalPosition": 15,
              "body": "I wanted to try a consistent framing between \"this is make `certificate_authorities` more useful\" and \"this is straight-up impossible\". I think the former is a better framing because a lot of deployments *can* use `certificate_authorities` today. Like it's just fine for client certs.\r\n\r\nHow's this new version?",
              "createdAt": "2024-09-10T18:38:58Z",
              "updatedAt": "2024-09-10T18:39:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6ItCkj",
          "commit": {
            "abbreviatedOid": "ca7925e"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-09-10T19:00:58Z",
          "updatedAt": "2024-09-10T19:00:58Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKigz-s6It9wR",
          "commit": {
            "abbreviatedOid": "79317ab"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-10T20:54:25Z",
          "updatedAt": "2024-09-10T20:54:25Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Not the hill to die on today then, but really, I find using the language \"untrustworthy\" referring to a \"CA\" as opposed to a \"CA operator\" a bit jarring. ",
              "createdAt": "2024-09-10T20:54:25Z",
              "updatedAt": "2024-09-10T20:54:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6It95v",
          "commit": {
            "abbreviatedOid": "79317ab"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-09-10T20:54:48Z",
          "updatedAt": "2024-09-10T20:54:48Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKigz-s6IuJ3d",
          "commit": {
            "abbreviatedOid": "79317ab"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-10T21:23:29Z",
          "updatedAt": "2024-09-10T21:23:30Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "```suggestion\r\nThe remainder of this section discusses what this problem statement means, and why it is important to solve. Subsequent sections provide an overview of the two solutions, discussion on design goals and key cases, and finally some alternatives we considered, including various existing solutions (e.g. fingerprinting and cross-signing), which do not meet the design goals.\r\n```",
              "createdAt": "2024-09-10T21:23:29Z",
              "updatedAt": "2024-09-10T21:23:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6IuKBc",
          "commit": {
            "abbreviatedOid": "79317ab"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-09-10T21:23:57Z",
          "updatedAt": "2024-09-10T21:23:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 75,
      "id": "PR_kwDOKigz-s59grjA",
      "title": "Switch \"subscriber\" to \"authenticating party\"",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/75",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "devonobrien",
        "bob-beck"
      ],
      "labels": [],
      "body": "Closes #74. I've left draft-davidben-tls-trust-expr alone for now, since we currently expect to use draft-beck-tls-trust-anchor-ids as a starting point.",
      "createdAt": "2024-10-03T14:36:52Z",
      "updatedAt": "2024-10-03T15:52:21Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "274116ce1082463992b04fcc3a85579f01ca315e",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "auth-party",
      "headRefOid": "efdfe0135f769e81f4e0ceeb59e21bb08bc24607",
      "closedAt": "2024-10-03T15:45:45Z",
      "mergedAt": "2024-10-03T15:45:45Z",
      "mergedBy": "bob-beck",
      "mergeCommit": {
        "oid": "1739f03458eeb5ce45cf244b09cb98797e755fe3"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 77,
      "id": "PR_kwDOKigz-s6A3lvU",
      "title": "Fix typo",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/77",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Got a few words in order wrong the.",
      "createdAt": "2024-11-05T01:03:21Z",
      "updatedAt": "2025-02-25T15:36:23Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "1d274a5f98b9f1d1ba2fec42455b379d3a7346a9",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "fix-typo",
      "headRefOid": "24cac4e7a0e9ecf43f8b87e269dffd56c4f1a4cb",
      "closedAt": "2024-11-05T11:22:31Z",
      "mergedAt": "2024-11-05T11:22:31Z",
      "mergedBy": "bob-beck",
      "mergeCommit": {
        "oid": "434c61d64489bef00adf81085144f32104172df2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6P91Pj",
          "commit": {
            "abbreviatedOid": "24cac4e"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-11-05T11:22:24Z",
          "updatedAt": "2024-11-05T11:22:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 78,
      "id": "PR_kwDOKigz-s6BUPaF",
      "title": "Add Kyle Nekritz as coauthor",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/78",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@knekritz looks good to you? Wasn't quite sure how you preferred to be listed.",
      "createdAt": "2024-11-08T12:36:42Z",
      "updatedAt": "2024-11-08T13:02:47Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "434c61d64489bef00adf81085144f32104172df2",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "coauthor",
      "headRefOid": "50644ce51bc606ad134a1878054328185196dfd0",
      "closedAt": "2024-11-08T13:01:48Z",
      "mergedAt": "2024-11-08T13:01:48Z",
      "mergedBy": "bob-beck",
      "mergeCommit": {
        "oid": "54aa73d0fa9b9f76b93f541f7d6ca4d0544ee6c5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6Qd2lJ",
          "commit": {
            "abbreviatedOid": "50644ce"
          },
          "author": "knekritz",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-11-08T13:01:10Z",
          "updatedAt": "2024-11-08T13:01:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 80,
      "id": "PR_kwDOKigz-s6EoCIz",
      "title": "Trim the ACME section a bit",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/80",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Based on feedback from @aarongable, let's just define the media type and how to use it with the existing ACME mechanisms. In particular, the alternate chain mechanism is not quite ideal for parallel issuance. Parallel issuance can be better solved in a separate document, as it's really orthogonal to the exact trust anchor negotiation strategy.\r\n\r\nThere's probably other bits we can trim, but I've left them alone for now.",
      "createdAt": "2024-12-10T00:45:05Z",
      "updatedAt": "2024-12-10T20:47:24Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "bde7925e5f4eaf20b53a9fefb89b03bd2e872f95",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "acme-update",
      "headRefOid": "d0c81dadfad95eec7b032795b370297e14bd36aa",
      "closedAt": "2024-12-10T20:47:22Z",
      "mergedAt": "2024-12-10T20:47:22Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "2245ae5b0c6afba71baac3eee7ac61afa3830c8b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6UchUR",
          "commit": {
            "abbreviatedOid": "855c6c7"
          },
          "author": "aarongable",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM with typo fix",
          "createdAt": "2024-12-10T00:57:04Z",
          "updatedAt": "2024-12-10T00:58:49Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "```suggestion\r\nWhile this document does not prescribe a specific configuration format or provisioning process, this section defines optional extensions to aid TLS applications using PEM {{!RFC7468}} or ACME {{!RFC8555}}.\r\n```",
              "createdAt": "2024-12-10T00:57:05Z",
              "updatedAt": "2024-12-10T00:58:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6Um7cB",
          "commit": {
            "abbreviatedOid": "d0c81da"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good to me. ",
          "createdAt": "2024-12-10T18:25:23Z",
          "updatedAt": "2024-12-10T18:25:23Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKigz-s6UnCau",
          "commit": {
            "abbreviatedOid": "d0c81da"
          },
          "author": "aarongable",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-12-10T18:38:45Z",
          "updatedAt": "2024-12-10T18:38:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 81,
      "id": "PR_kwDOKigz-s6FFRAx",
      "title": "Update Dilithium reference to ML-DSA",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/81",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-12-12T23:57:20Z",
      "updatedAt": "2024-12-13T00:33:05Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "2245ae5b0c6afba71baac3eee7ac61afa3830c8b",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "mldsa",
      "headRefOid": "c0310746343005cb0f2d773ace7ecb6c672bba5d",
      "closedAt": "2024-12-13T00:33:02Z",
      "mergedAt": "2024-12-13T00:33:02Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "13a61ccc101450aadcba87d95a61f93ac282b88f"
      },
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "NONE",
          "body": "Sizes are slightly different for the final standard.\r\n\r\n<img width=\"530\" alt=\"Screenshot 2024-12-13 at 01 05 04\" src=\"https://github.com/user-attachments/assets/db63e995-b3ea-446b-be44-612be593c52f\" />\r\n",
          "createdAt": "2024-12-13T00:06:54Z",
          "updatedAt": "2024-12-13T00:06:54Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Derp. I thought I went to check this but looked at the initial public draft instead. I see they made them bigger. \ud83d\ude22 ",
          "createdAt": "2024-12-13T00:22:03Z",
          "updatedAt": "2024-12-13T00:22:03Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6VEp4t",
          "commit": {
            "abbreviatedOid": "c031074"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-12-13T00:29:21Z",
          "updatedAt": "2024-12-13T00:29:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 82,
      "id": "PR_kwDOKigz-s6FMgEr",
      "title": "Section 8 cleanup for -03 draft",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/82",
      "state": "MERGED",
      "author": "devonobrien",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Removed much of the 'multi-certificate-model' text from Section 8, reworked a couple subsections, and rearranged for more clarity. Part of wider cleanup for issue #28.",
      "createdAt": "2024-12-13T22:35:30Z",
      "updatedAt": "2025-02-25T15:37:07Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "13a61ccc101450aadcba87d95a61f93ac282b88f",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "devonobrien-section-8-cleanup",
      "headRefOid": "3e9373f02229a16875627f6ed67b7d941ad6899e",
      "closedAt": "2024-12-13T23:55:09Z",
      "mergedAt": "2024-12-13T23:55:09Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "1c6c2d0d20fb84bce9ef13840646dae87a5a1097"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6VNuZO",
          "commit": {
            "abbreviatedOid": "3e9373f"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-12-13T23:55:05Z",
          "updatedAt": "2024-12-13T23:55:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 83,
      "id": "PR_kwDOKigz-s6FPHqO",
      "title": "Move CertificatePropertyList definition to later",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/83",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Playing with a slightly different structure. We actually don't refer to this structure much. The thinking here is that, like the ACME extension and the media type, this isn't really fundamental to the extension, just a RECOMMENDED way to deploy it. This lets us get to the meat of the mechanism sooner.\r\n\r\nI also demoted it from the glossary, since it's now only relevant for the \"optional but recommended\" section.\r\n\r\nThoughts?",
      "createdAt": "2024-12-14T19:04:10Z",
      "updatedAt": "2024-12-16T22:03:26Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "1c6c2d0d20fb84bce9ef13840646dae87a5a1097",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "move-cpl",
      "headRefOid": "053c7fdb355bc5f67868de5f85a8c1d8053b1596",
      "closedAt": "2024-12-16T22:03:23Z",
      "mergedAt": "2024-12-16T22:03:23Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "a7f3f2f7512a940a32c8a9a7d281aa712b52dd5d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6Vc_p_",
          "commit": {
            "abbreviatedOid": "053c7fd"
          },
          "author": "devonobrien",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Yeah, I think demoting the prominence of CPL and setting it as recommended are overall good changes. It's a bit unfortunate we don't have a more concrete definition for CPLs that can be used as a reference, but this will definitely do for now.",
          "createdAt": "2024-12-16T21:35:38Z",
          "updatedAt": "2024-12-16T21:35:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 84,
      "id": "PR_kwDOKigz-s6FPIc6",
      "title": "Remove trust exprs comparison from draft-beck-tls-trust-anchor-ids",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/84",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The comparison is in the explainer and no longer needed in the draft itself.",
      "createdAt": "2024-12-14T19:14:58Z",
      "updatedAt": "2025-02-25T15:36:14Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "1c6c2d0d20fb84bce9ef13840646dae87a5a1097",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "trust-expr-compare",
      "headRefOid": "88bd16c929728ec7aa5a8dc11df2f2b20fb62903",
      "closedAt": "2024-12-16T21:24:56Z",
      "mergedAt": "2024-12-16T21:24:56Z",
      "mergedBy": "devonobrien",
      "mergeCommit": {
        "oid": "6328eb6f4e5f175798ba4a545e4989a38fe3fe63"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6Vc7mK",
          "commit": {
            "abbreviatedOid": "88bd16c"
          },
          "author": "devonobrien",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-12-16T21:24:40Z",
          "updatedAt": "2024-12-16T21:24:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 85,
      "id": "PR_kwDOKigz-s6FRe1C",
      "title": "Add a copy of the ASN.1 module to the appendix",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/85",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I think this is the right syntax? Not that there's really much of an ASN.1 module here at all. Closes #41",
      "createdAt": "2024-12-15T19:18:15Z",
      "updatedAt": "2024-12-16T22:03:03Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "6328eb6f4e5f175798ba4a545e4989a38fe3fe63",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "asn1-module",
      "headRefOid": "cdb2ac7c99f6b3722388dbef67f0a7a18f257cfd",
      "closedAt": "2024-12-16T22:03:01Z",
      "mergedAt": "2024-12-16T22:03:01Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "72a40c3b1846d94a1a7515044f54c76f62bb74b4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6VdAzr",
          "commit": {
            "abbreviatedOid": "d1a4a70"
          },
          "author": "devonobrien",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-12-16T21:38:49Z",
          "updatedAt": "2024-12-16T21:38:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 86,
      "id": "PR_kwDOKigz-s6FRfSw",
      "title": "Slight tweak to wording of X.509 extension",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/86",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I think it's better to say the trust anchor is *represented* as an X.509 certificate rather than that it *is* an X.509 certificate. You might represent the \"same\" trust anchor in different ways. RFC 5280 doesn't do a great job of nailing this down.\r\n\r\nAlso drop the \"self-signed\" because it might be, e.g., draft-davidben-x509-alg-none. (But I don't think it actually makes sense to cite that draft, so just leave it unspecified.)",
      "createdAt": "2024-12-15T19:23:32Z",
      "updatedAt": "2024-12-16T19:07:55Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "1c6c2d0d20fb84bce9ef13840646dae87a5a1097",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "not-necessarily-self-signed",
      "headRefOid": "061a241f570d59952fabf8391a2b09e029b03384",
      "closedAt": "2024-12-16T17:33:30Z",
      "mergedAt": "2024-12-16T17:33:30Z",
      "mergedBy": "devonobrien",
      "mergeCommit": {
        "oid": "8acd81be49f644c3028d02a507415ef692a1668c"
      },
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "NONE",
          "body": "This naturally leads to another question you might want to address: if a TA has different representations then surely they would use the same public key? ;)",
          "createdAt": "2024-12-16T11:36:43Z",
          "updatedAt": "2024-12-16T11:36:43Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Not sure I follow. Trust anchors are a notion from X.509. We're not defining them or anything. And, yes, if you change the public key, that's decidedly not the same trust anchor.",
          "createdAt": "2024-12-16T13:01:54Z",
          "updatedAt": "2024-12-16T13:01:54Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "(if you change the subject name, it's also not the same trust anchor. If you change other stuff, it gets more complicated, but that's a core X.509 ambiguity and not specific to this document.)",
          "createdAt": "2024-12-16T13:03:08Z",
          "updatedAt": "2024-12-16T13:03:08Z"
        },
        {
          "author": "devonobrien",
          "authorAssociation": "COLLABORATOR",
          "body": "In light of redefining TAs as Subject + Public Key in PR #88 , I think \"represented by\" is clear and unambiguous. ",
          "createdAt": "2024-12-16T17:28:38Z",
          "updatedAt": "2024-12-16T17:29:50Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6Va3a6",
          "commit": {
            "abbreviatedOid": "061a241"
          },
          "author": "devonobrien",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-12-16T17:29:31Z",
          "updatedAt": "2024-12-16T17:29:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 87,
      "id": "PR_kwDOKigz-s6FSCz3",
      "title": "Tighten up privacy and security considerations",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/87",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Did an editorial pass. Hopefully this is shorter and clearer.",
      "createdAt": "2024-12-16T00:01:52Z",
      "updatedAt": "2024-12-17T20:37:38Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "a7f3f2f7512a940a32c8a9a7d281aa712b52dd5d",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "privacy-security-considerations",
      "headRefOid": "a867fa6fd99ed039bdd17937a009d6e931be9b61",
      "closedAt": "2024-12-17T20:37:35Z",
      "mergedAt": "2024-12-17T20:37:35Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "898526e0d2480fac5625796fed1e92e8c66261c5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6VdFUe",
          "commit": {
            "abbreviatedOid": "c5dbf72"
          },
          "author": "devonobrien",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-16T21:51:28Z",
          "updatedAt": "2024-12-16T22:44:21Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nThe `trust_anchors` extension is analogous to the `certificate_authorities` extension ({{Section 4.2.4 of RFC8446}}), but more size-efficient. Like `certificate_authorities`, `trust_anchors` reveals some information about the relying party's trust anchors. However, unlike `certificate_authorities`, `trust_anchors` allows a relying party to only reveal a trust anchor in response to the authenticating party's list, which reduces the fingerprinting exposure. This section provides guidance for a relying party to configure this mechanism, based on its privacy goals.\r\n```",
              "createdAt": "2024-12-16T21:51:28Z",
              "updatedAt": "2024-12-16T22:44:21Z"
            },
            {
              "originalPosition": 18,
              "body": "The 3 part categorization above isn't fully covered by the \"Each of these categories\" fingerprinting exposure analysis directly following. It's rather trivial, but we could simply state that trust anchors not participating in the mechanism do not introduce fingerprinting exposure.",
              "createdAt": "2024-12-16T21:55:58Z",
              "updatedAt": "2024-12-16T22:44:21Z"
            },
            {
              "originalPosition": 32,
              "body": "```suggestion\r\nIf the authenticating party has provisioned certification paths with incorrect trust anchor identifier information, it may inadvertently send untrusted certification paths when matching against this identifier and additionally may overlook this certification path when attempting to match against the correct identifier. In either case, this will not result in that path becoming trusted, but the connection will fail when this leads to the selection of an untrusted certification path.\r\n```",
              "createdAt": "2024-12-16T22:03:48Z",
              "updatedAt": "2024-12-16T22:44:21Z"
            },
            {
              "originalPosition": 66,
              "body": "```suggestion\r\nRather, it is the relying party's choice of trusted CAs that determines susceptibility to interception. If the relying party trusts a misbehaving or attacker-controlled CA, the attacker can intercept the connection with a public key certified by that CA, regardless of which CA is used by the intended authenticating party. Conversely, if the relying party does not trust the attacker's CA, the attacker cannot successfully intercept the connection using a public key certified by this CA.\r\n```",
              "createdAt": "2024-12-16T22:43:14Z",
              "updatedAt": "2024-12-16T22:44:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6VdcJZ",
          "commit": {
            "abbreviatedOid": "c5dbf72"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-16T23:00:23Z",
          "updatedAt": "2024-12-16T23:00:23Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "It's kind of covered by \"This is similar to the baseline exposure for trust anchors that do not participate in negotiation. [...]\" but I agree this is kinda weird. Will take another pass.",
              "createdAt": "2024-12-16T23:00:23Z",
              "updatedAt": "2024-12-16T23:00:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6Vd8zI",
          "commit": {
            "abbreviatedOid": "1427b63"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-17T01:11:14Z",
          "updatedAt": "2024-12-17T01:11:15Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "I reversed the order, which I think made it flow a bit better. How's this read?",
              "createdAt": "2024-12-17T01:11:14Z",
              "updatedAt": "2024-12-17T01:11:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6Vd82K",
          "commit": {
            "abbreviatedOid": "c5dbf72"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-17T01:11:29Z",
          "updatedAt": "2024-12-17T01:11:29Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Applied and then wordsmithed.",
              "createdAt": "2024-12-17T01:11:29Z",
              "updatedAt": "2024-12-17T01:11:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6VlIkO",
          "commit": {
            "abbreviatedOid": "1427b63"
          },
          "author": "devonobrien",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-12-17T17:08:23Z",
          "updatedAt": "2024-12-17T17:08:38Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "```suggestion\r\nHowever, trust anchor negotiation only impacts detection where this differentiation was not already possible. In TLS, the client offers all its available TLS features, including cipher suites and other extensions, in the TLS ClientHello. Any variation in client TLS policies, related or unrelated to trust anchors, may be used as a fingerprint. Transport properties, such as IP geolocation, may also be used. While fingerprinting's heuristic nature makes broad, legitimate use difficult, a network attacker's single interception service can easily use it for targeted attacks.\r\n```",
              "createdAt": "2024-12-17T17:08:24Z",
              "updatedAt": "2024-12-17T17:08:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6VlMCM",
          "commit": {
            "abbreviatedOid": "1427b63"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-17T17:13:02Z",
          "updatedAt": "2024-12-17T17:13:03Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "authenticating party's behaviour.\r\n(or give up and use client and server througout)",
              "createdAt": "2024-12-17T17:13:02Z",
              "updatedAt": "2024-12-17T17:13:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6VlPny",
          "commit": {
            "abbreviatedOid": "1427b63"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-17T17:18:50Z",
          "updatedAt": "2024-12-17T17:18:51Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "```suggestion\r\nNegotiation also reduces pressures on relying parties to sacrifice user security for compatibility. If a relying party does not trust an authenticating party's current CA, connections between the two will fail until either the relying party trusts the CA or the authenticating party uses an already trusted CA. Without trust anchor negotiation, the authenticating party is limited to one certificate, and therefore switching CAs risks compatibility problems with other relying parties. The relying party then faces compatibility pressure to add this CA, even if it deems the CA a security risk. With trust anchor negotiation, the authenticating party can use its existing CA _in addition to_ another CA trusted by the relying party. This allows the ecosystem to improve interoperability without sacrificing user security.\r\n```",
              "createdAt": "2024-12-17T17:18:50Z",
              "updatedAt": "2024-12-17T17:18:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6VlQxu",
          "commit": {
            "abbreviatedOid": "1427b63"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-17T17:20:26Z",
          "updatedAt": "2024-12-17T17:20:27Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "```suggestion\r\nTrust anchor negotiation reduces compatibility pressures against authenticating parties serving certificates from a less common CA, as they can be served with other certificates. In some cases, the CA may have been distrusted, but still used to support older relying parties. As discussed in {{use-cases}} and {{agility}}, this capability aids PKI transitions that mitigate security risks to users.\r\n```",
              "createdAt": "2024-12-17T17:20:27Z",
              "updatedAt": "2024-12-17T17:20:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6VlUKW",
          "commit": {
            "abbreviatedOid": "1427b63"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-17T17:26:42Z",
          "updatedAt": "2024-12-17T17:26:42Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "```suggestion\r\nTrust anchors that do not participate are not revealed by this extension. Without this extension, such trust anchors already have fingerprinting exposure. Given a certification path, an authenticating party can probe whether the relying party trusts the trust anchor by seeing if the relying party accepts it.\r\n```",
              "createdAt": "2024-12-17T17:26:42Z",
              "updatedAt": "2024-12-17T17:26:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6VlU7T",
          "commit": {
            "abbreviatedOid": "1427b63"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-17T17:27:53Z",
          "updatedAt": "2024-12-17T17:27:53Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "```suggestion\r\nTrust anchor identifiers sent in response to the authenticating party can only be observed actively. That is, the authenticating party could vary its list and observe how the client responds, in order to probe for the client's trust anchor list. This is similar to the exposure of trust anchors not participating in this extension, except that the trust anchor can be probed by only knowing the trust anchor identifier.\r\n```",
              "createdAt": "2024-12-17T17:27:53Z",
              "updatedAt": "2024-12-17T17:27:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6VlVBu",
          "commit": {
            "abbreviatedOid": "1427b63"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-12-17T17:28:03Z",
          "updatedAt": "2024-12-17T17:28:03Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKigz-s6Vl4Q4",
          "commit": {
            "abbreviatedOid": "1427b63"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-17T18:23:02Z",
          "updatedAt": "2024-12-17T18:23:03Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Oops, nice catch.\r\n\r\n```suggestion\r\n3. Trust anchors whose identifiers the relying party sends *unconditionally*, i.e. independently of the authenticating party's behavior.\r\n```",
              "createdAt": "2024-12-17T18:23:02Z",
              "updatedAt": "2024-12-17T18:23:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6VnGYE",
          "commit": {
            "abbreviatedOid": "1427b63"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-17T20:36:53Z",
          "updatedAt": "2024-12-17T20:36:53Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Wordsmithed slightly. (Reads weird without the connecting word.)\r\n\r\n```suggestion\r\nTrust anchors that do not participate are not revealed by this extension. However, they have some fingerprinting exposure due to being trusted. Given a certification path, an authenticating party can probe whether the relying party trusts the trust anchor by seeing if the relying party accepts it.\r\n```",
              "createdAt": "2024-12-17T20:36:53Z",
              "updatedAt": "2024-12-17T20:36:53Z"
            }
          ]
        }
      ]
    },
    {
      "number": 88,
      "id": "PR_kwDOKigz-s6FXZ7X",
      "title": "Fix the definition of a trust anchor",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/88",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Prompted by chatting with @bwesterb\r\n\r\nA trust anchor is not just a pre-distributed key. It also, at minimum, includes the name. It is also not a self-signed certificate. Self-signed certificates are just a common way to specify them. Just cite the definition from RFC 5280.\r\n\r\nAn astute reader of RFC 5280 might notice that this implies no other properties of the root certificate (when using one) matter. This is... complicated.  Path validation takes a bunch of extra things as inputs. RFC 5937 discusses how to fill in those parameters from other values in the root certificate. This means, formally, a trust anchor is just the name and key, and then any other constraints the application applies are just decisions it made in how to set those other inputs. Those inputs don't cover all application behaviors in practice. You can think of this as application-specific extensions of Section 6.1 to add more inputs to the process.\r\n\r\nWe don't current discuss or handle those specifically. Possibly worth some discussion, but I'll leave that for a separate PR. Broadly, the answers there are:\r\n\r\n- The CA should mostly know what constraints its under and should mostly not issue certs incompatible with that\r\n\r\n- If it does, the retry flow allows the client to ask for a new cert and try again",
      "createdAt": "2024-12-16T14:32:40Z",
      "updatedAt": "2024-12-16T19:07:47Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "1c6c2d0d20fb84bce9ef13840646dae87a5a1097",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "trust-anchor",
      "headRefOid": "51772e5d7a3d5fb383e2b9175ed394f7c499aa11",
      "closedAt": "2024-12-16T17:26:04Z",
      "mergedAt": "2024-12-16T17:26:04Z",
      "mergedBy": "devonobrien",
      "mergeCommit": {
        "oid": "8deaa06ea975dfdde3b0e07ed04bce1457d4f09f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6VZCPF",
          "commit": {
            "abbreviatedOid": "51772e5"
          },
          "author": "bwesterb",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-12-16T14:35:34Z",
          "updatedAt": "2024-12-16T14:35:34Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKigz-s6Vaz7a",
          "commit": {
            "abbreviatedOid": "51772e5"
          },
          "author": "devonobrien",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-12-16T17:23:45Z",
          "updatedAt": "2024-12-16T17:23:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 89,
      "id": "PR_kwDOKigz-s6JbZiG",
      "title": "Create empty TAI assignments table with basic instructions for assignment",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/89",
      "state": "MERGED",
      "author": "devonobrien",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-01-29T22:13:40Z",
      "updatedAt": "2025-01-30T20:38:56Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "0fbe9935021ec86f1d7ed8dddcbe04b29b0247e4",
      "headRepository": "devonobrien/tls-trust-anchor-ids",
      "headRefName": "main",
      "headRefOid": "3553d19305d93a2c162c2faa014575b252015897",
      "closedAt": "2025-01-30T20:19:10Z",
      "mergedAt": "2025-01-30T20:19:10Z",
      "mergedBy": "devonobrien",
      "mergeCommit": {
        "oid": "c59a314586c3ea819b4603af816d9c97ac777237"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6aE5YQ",
          "commit": {
            "abbreviatedOid": "3553d19"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-30T20:38:56Z",
          "updatedAt": "2025-01-30T20:38:56Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Oops, sorry missed this. LGTM but one comment: this uses the text form of the subject name, I think close-ish to RFC 2253 though OpenSSL's API has lots of options and I don't know which they use for `-subject`.\r\n\r\nThe problem is RFC 2253's syntax is not actually enough to give you back the name. It might be enough up to normalization, but normalization is kind of cursed. (The text syntax doesn't tell you what string type each field used.) I'm not sure what's the best thing to do here. There isn't an easy way to get a hex dump of the subject name.",
              "createdAt": "2025-01-30T20:38:56Z",
              "updatedAt": "2025-01-30T20:38:56Z"
            }
          ]
        }
      ]
    },
    {
      "number": 90,
      "id": "PR_kwDOKigz-s6KEQ37",
      "title": "Add a note about storage requirements for intermediates vs trust anchors",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/90",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-02-05T00:10:04Z",
      "updatedAt": "2025-02-05T00:41:24Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "96d2215df233710bd9743f2ac5c5aaa889999357",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "trust-anchor-storage",
      "headRefOid": "3140a2c3e650d9caf41202ff0517b4817b27f439",
      "closedAt": "2025-02-05T00:41:21Z",
      "mergedAt": "2025-02-05T00:41:21Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "1e28001341e681150b3d5bafa31e201e6823e47e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6aosh7",
          "commit": {
            "abbreviatedOid": "a3dbd44"
          },
          "author": "nharper",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-05T00:15:12Z",
          "updatedAt": "2025-02-05T00:15:12Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "> Crucially, there is no need to ship signatures with intermediates.\r\n\r\nI don't follow - should \"intermediates\" here be \"intermediates-as-trust-anchors\"?",
              "createdAt": "2025-02-05T00:15:12Z",
              "updatedAt": "2025-02-05T00:15:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6aoxZ-",
          "commit": {
            "abbreviatedOid": "a3dbd44"
          },
          "author": "bob-beck",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-02-05T00:37:00Z",
          "updatedAt": "2025-02-05T00:37:18Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I might avoid the confusion by modifying this to\r\n\r\n\"while a trust anchor needs only subject information and a public key.  There is no need to ship signatures with a trust anchor.\"",
              "createdAt": "2025-02-05T00:37:00Z",
              "updatedAt": "2025-02-05T00:37:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKigz-s6aoyD6",
          "commit": {
            "abbreviatedOid": "a3dbd44"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-05T00:39:55Z",
          "updatedAt": "2025-02-05T00:39:55Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "The public key is subject information. It's the _subject_ public key info. :-P Though yeah \"with intermediates\" was a typo. Will fix.",
              "createdAt": "2025-02-05T00:39:55Z",
              "updatedAt": "2025-02-05T00:39:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 93,
      "id": "PR_kwDOKigz-s6MGg_R",
      "title": "Prepare repository for transition to tlswg",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/93",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Remove draft-davidben-tls-trust-expr (still in git history if anyone wants it for reference), and preface most of the supplementary documents with a historical note.\r\n\r\nThis does not (yet) rename the document, or update URLs. I figure that's best done after we transfer + rename the repository. But we can get this part sorted out first.\r\n\r\nAlso close out all the old trust-exprs issues:\r\n\r\n* Closes #26\r\n* Closes #25\r\n* Closes #17\r\n* Closes #13\r\n* Closes #1",
      "createdAt": "2025-02-21T21:07:10Z",
      "updatedAt": "2025-02-25T15:35:14Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "1e28001341e681150b3d5bafa31e201e6823e47e",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "prep-transfer",
      "headRefOid": "ce61e99590b3cd281d7a6b2fca4566fad7ed7072",
      "closedAt": "2025-02-22T00:46:54Z",
      "mergedAt": "2025-02-22T00:46:54Z",
      "mergedBy": "devonobrien",
      "mergeCommit": {
        "oid": "86bf01b1f41b3ca4ae94b34c23639d297f0b95fe"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6dAz4w",
          "commit": {
            "abbreviatedOid": "ce61e99"
          },
          "author": "dconnolly",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "lgtm!",
          "createdAt": "2025-02-21T21:17:04Z",
          "updatedAt": "2025-02-21T21:17:04Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKigz-s6dBcr5",
          "commit": {
            "abbreviatedOid": "ce61e99"
          },
          "author": "devonobrien",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Repo prep for tlswg transfer LGTM.",
          "createdAt": "2025-02-21T22:26:04Z",
          "updatedAt": "2025-02-21T22:26:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 94,
      "id": "PR_kwDOKigz-s6MWhUk",
      "title": "Finish renaming the draft post-repo transfer",
      "url": "https://github.com/tlswg/tls-trust-anchor-ids/pull/94",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-02-24T20:59:28Z",
      "updatedAt": "2025-02-25T01:27:38Z",
      "baseRepository": "tlswg/tls-trust-anchor-ids",
      "baseRefName": "main",
      "baseRefOid": "86bf01b1f41b3ca4ae94b34c23639d297f0b95fe",
      "headRepository": "tlswg/tls-trust-anchor-ids",
      "headRefName": "rename-2",
      "headRefOid": "6d4b183cbf6ef1c4b84a5f19417eef13ab1400d0",
      "closedAt": "2025-02-25T01:27:31Z",
      "mergedAt": "2025-02-25T01:27:31Z",
      "mergedBy": "davidben",
      "mergeCommit": {
        "oid": "ae24c09d83296c1e30ad36db7e61de29d8d15ebb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKigz-s6dScus",
          "commit": {
            "abbreviatedOid": "6d4b183"
          },
          "author": "devonobrien",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-02-25T01:16:04Z",
          "updatedAt": "2025-02-25T01:16:04Z",
          "comments": []
        }
      ]
    }
  ]
}